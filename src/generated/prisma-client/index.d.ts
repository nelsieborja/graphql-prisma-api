// Code generated by Prisma (prisma@1.23.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  banner: (where?: BannerWhereInput) => Promise<boolean>;
  bannerImage: (where?: BannerImageWhereInput) => Promise<boolean>;
  cart: (where?: CartWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  popularCategory: (where?: PopularCategoryWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productImage: (where?: ProductImageWhereInput) => Promise<boolean>;
  productOverviewImage: (
    where?: ProductOverviewImageWhereInput
  ) => Promise<boolean>;
  productOverviewText: (
    where?: ProductOverviewTextWhereInput
  ) => Promise<boolean>;
  productSpec: (where?: ProductSpecWhereInput) => Promise<boolean>;
  productSpecDesc: (where?: ProductSpecDescWhereInput) => Promise<boolean>;
  productVariant: (where?: ProductVariantWhereInput) => Promise<boolean>;
  productVariantSpec: (
    where?: ProductVariantSpecWhereInput
  ) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  stars: (where?: StarsWhereInput) => Promise<boolean>;
  topPick: (where?: TopPickWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  variant: (where?: VariantWhereInput) => Promise<boolean>;
  vote: (where?: VoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  banner: (where: BannerWhereUniqueInput) => BannerPromise;
  banners: (
    args?: {
      where?: BannerWhereInput;
      orderBy?: BannerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Banner>;
  bannersConnection: (
    args?: {
      where?: BannerWhereInput;
      orderBy?: BannerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BannerConnectionPromise;
  bannerImage: (where: BannerImageWhereUniqueInput) => BannerImagePromise;
  bannerImages: (
    args?: {
      where?: BannerImageWhereInput;
      orderBy?: BannerImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BannerImage>;
  bannerImagesConnection: (
    args?: {
      where?: BannerImageWhereInput;
      orderBy?: BannerImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BannerImageConnectionPromise;
  cart: (where: CartWhereUniqueInput) => CartPromise;
  carts: (
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cart>;
  cartsConnection: (
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CartConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  popularCategory: (
    where: PopularCategoryWhereUniqueInput
  ) => PopularCategoryPromise;
  popularCategories: (
    args?: {
      where?: PopularCategoryWhereInput;
      orderBy?: PopularCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PopularCategory>;
  popularCategoriesConnection: (
    args?: {
      where?: PopularCategoryWhereInput;
      orderBy?: PopularCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PopularCategoryConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  productImage: (where: ProductImageWhereUniqueInput) => ProductImagePromise;
  productImages: (
    args?: {
      where?: ProductImageWhereInput;
      orderBy?: ProductImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductImage>;
  productImagesConnection: (
    args?: {
      where?: ProductImageWhereInput;
      orderBy?: ProductImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductImageConnectionPromise;
  productOverviewImage: (
    where: ProductOverviewImageWhereUniqueInput
  ) => ProductOverviewImagePromise;
  productOverviewImages: (
    args?: {
      where?: ProductOverviewImageWhereInput;
      orderBy?: ProductOverviewImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductOverviewImage>;
  productOverviewImagesConnection: (
    args?: {
      where?: ProductOverviewImageWhereInput;
      orderBy?: ProductOverviewImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductOverviewImageConnectionPromise;
  productOverviewText: (
    where: ProductOverviewTextWhereUniqueInput
  ) => ProductOverviewTextPromise;
  productOverviewTexts: (
    args?: {
      where?: ProductOverviewTextWhereInput;
      orderBy?: ProductOverviewTextOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductOverviewText>;
  productOverviewTextsConnection: (
    args?: {
      where?: ProductOverviewTextWhereInput;
      orderBy?: ProductOverviewTextOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductOverviewTextConnectionPromise;
  productSpec: (where: ProductSpecWhereUniqueInput) => ProductSpecPromise;
  productSpecs: (
    args?: {
      where?: ProductSpecWhereInput;
      orderBy?: ProductSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductSpec>;
  productSpecsConnection: (
    args?: {
      where?: ProductSpecWhereInput;
      orderBy?: ProductSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductSpecConnectionPromise;
  productSpecDesc: (
    where: ProductSpecDescWhereUniqueInput
  ) => ProductSpecDescPromise;
  productSpecDescs: (
    args?: {
      where?: ProductSpecDescWhereInput;
      orderBy?: ProductSpecDescOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductSpecDesc>;
  productSpecDescsConnection: (
    args?: {
      where?: ProductSpecDescWhereInput;
      orderBy?: ProductSpecDescOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductSpecDescConnectionPromise;
  productVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  productVariants: (
    args?: {
      where?: ProductVariantWhereInput;
      orderBy?: ProductVariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductVariant>;
  productVariantsConnection: (
    args?: {
      where?: ProductVariantWhereInput;
      orderBy?: ProductVariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductVariantConnectionPromise;
  productVariantSpec: (
    where: ProductVariantSpecWhereUniqueInput
  ) => ProductVariantSpecPromise;
  productVariantSpecs: (
    args?: {
      where?: ProductVariantSpecWhereInput;
      orderBy?: ProductVariantSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductVariantSpec>;
  productVariantSpecsConnection: (
    args?: {
      where?: ProductVariantSpecWhereInput;
      orderBy?: ProductVariantSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductVariantSpecConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewPromise;
  reviews: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Review>;
  reviewsConnection: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReviewConnectionPromise;
  stars: (where: StarsWhereUniqueInput) => StarsPromise;
  starses: (
    args?: {
      where?: StarsWhereInput;
      orderBy?: StarsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Stars>;
  starsesConnection: (
    args?: {
      where?: StarsWhereInput;
      orderBy?: StarsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StarsConnectionPromise;
  topPick: (where: TopPickWhereUniqueInput) => TopPickPromise;
  topPicks: (
    args?: {
      where?: TopPickWhereInput;
      orderBy?: TopPickOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TopPick>;
  topPicksConnection: (
    args?: {
      where?: TopPickWhereInput;
      orderBy?: TopPickOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopPickConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  variant: (where: VariantWhereUniqueInput) => VariantPromise;
  variants: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Variant>;
  variantsConnection: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VariantConnectionPromise;
  vote: (where: VoteWhereUniqueInput) => VotePromise;
  votes: (
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Vote>;
  votesConnection: (
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBanner: (data: BannerCreateInput) => BannerPromise;
  updateBanner: (
    args: { data: BannerUpdateInput; where: BannerWhereUniqueInput }
  ) => BannerPromise;
  updateManyBanners: (
    args: { data: BannerUpdateManyMutationInput; where?: BannerWhereInput }
  ) => BatchPayloadPromise;
  upsertBanner: (
    args: {
      where: BannerWhereUniqueInput;
      create: BannerCreateInput;
      update: BannerUpdateInput;
    }
  ) => BannerPromise;
  deleteBanner: (where: BannerWhereUniqueInput) => BannerPromise;
  deleteManyBanners: (where?: BannerWhereInput) => BatchPayloadPromise;
  createBannerImage: (data: BannerImageCreateInput) => BannerImagePromise;
  updateBannerImage: (
    args: { data: BannerImageUpdateInput; where: BannerImageWhereUniqueInput }
  ) => BannerImagePromise;
  updateManyBannerImages: (
    args: {
      data: BannerImageUpdateManyMutationInput;
      where?: BannerImageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBannerImage: (
    args: {
      where: BannerImageWhereUniqueInput;
      create: BannerImageCreateInput;
      update: BannerImageUpdateInput;
    }
  ) => BannerImagePromise;
  deleteBannerImage: (where: BannerImageWhereUniqueInput) => BannerImagePromise;
  deleteManyBannerImages: (
    where?: BannerImageWhereInput
  ) => BatchPayloadPromise;
  createCart: (data: CartCreateInput) => CartPromise;
  updateCart: (
    args: { data: CartUpdateInput; where: CartWhereUniqueInput }
  ) => CartPromise;
  updateManyCarts: (
    args: { data: CartUpdateManyMutationInput; where?: CartWhereInput }
  ) => BatchPayloadPromise;
  upsertCart: (
    args: {
      where: CartWhereUniqueInput;
      create: CartCreateInput;
      update: CartUpdateInput;
    }
  ) => CartPromise;
  deleteCart: (where: CartWhereUniqueInput) => CartPromise;
  deleteManyCarts: (where?: CartWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createPopularCategory: (
    data: PopularCategoryCreateInput
  ) => PopularCategoryPromise;
  updatePopularCategory: (
    args: {
      data: PopularCategoryUpdateInput;
      where: PopularCategoryWhereUniqueInput;
    }
  ) => PopularCategoryPromise;
  updateManyPopularCategories: (
    args: {
      data: PopularCategoryUpdateManyMutationInput;
      where?: PopularCategoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPopularCategory: (
    args: {
      where: PopularCategoryWhereUniqueInput;
      create: PopularCategoryCreateInput;
      update: PopularCategoryUpdateInput;
    }
  ) => PopularCategoryPromise;
  deletePopularCategory: (
    where: PopularCategoryWhereUniqueInput
  ) => PopularCategoryPromise;
  deleteManyPopularCategories: (
    where?: PopularCategoryWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductImage: (data: ProductImageCreateInput) => ProductImagePromise;
  updateProductImage: (
    args: { data: ProductImageUpdateInput; where: ProductImageWhereUniqueInput }
  ) => ProductImagePromise;
  updateManyProductImages: (
    args: {
      data: ProductImageUpdateManyMutationInput;
      where?: ProductImageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductImage: (
    args: {
      where: ProductImageWhereUniqueInput;
      create: ProductImageCreateInput;
      update: ProductImageUpdateInput;
    }
  ) => ProductImagePromise;
  deleteProductImage: (
    where: ProductImageWhereUniqueInput
  ) => ProductImagePromise;
  deleteManyProductImages: (
    where?: ProductImageWhereInput
  ) => BatchPayloadPromise;
  createProductOverviewImage: (
    data: ProductOverviewImageCreateInput
  ) => ProductOverviewImagePromise;
  updateProductOverviewImage: (
    args: {
      data: ProductOverviewImageUpdateInput;
      where: ProductOverviewImageWhereUniqueInput;
    }
  ) => ProductOverviewImagePromise;
  updateManyProductOverviewImages: (
    args: {
      data: ProductOverviewImageUpdateManyMutationInput;
      where?: ProductOverviewImageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductOverviewImage: (
    args: {
      where: ProductOverviewImageWhereUniqueInput;
      create: ProductOverviewImageCreateInput;
      update: ProductOverviewImageUpdateInput;
    }
  ) => ProductOverviewImagePromise;
  deleteProductOverviewImage: (
    where: ProductOverviewImageWhereUniqueInput
  ) => ProductOverviewImagePromise;
  deleteManyProductOverviewImages: (
    where?: ProductOverviewImageWhereInput
  ) => BatchPayloadPromise;
  createProductOverviewText: (
    data: ProductOverviewTextCreateInput
  ) => ProductOverviewTextPromise;
  updateProductOverviewText: (
    args: {
      data: ProductOverviewTextUpdateInput;
      where: ProductOverviewTextWhereUniqueInput;
    }
  ) => ProductOverviewTextPromise;
  updateManyProductOverviewTexts: (
    args: {
      data: ProductOverviewTextUpdateManyMutationInput;
      where?: ProductOverviewTextWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductOverviewText: (
    args: {
      where: ProductOverviewTextWhereUniqueInput;
      create: ProductOverviewTextCreateInput;
      update: ProductOverviewTextUpdateInput;
    }
  ) => ProductOverviewTextPromise;
  deleteProductOverviewText: (
    where: ProductOverviewTextWhereUniqueInput
  ) => ProductOverviewTextPromise;
  deleteManyProductOverviewTexts: (
    where?: ProductOverviewTextWhereInput
  ) => BatchPayloadPromise;
  createProductSpec: (data: ProductSpecCreateInput) => ProductSpecPromise;
  updateProductSpec: (
    args: { data: ProductSpecUpdateInput; where: ProductSpecWhereUniqueInput }
  ) => ProductSpecPromise;
  updateManyProductSpecs: (
    args: {
      data: ProductSpecUpdateManyMutationInput;
      where?: ProductSpecWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductSpec: (
    args: {
      where: ProductSpecWhereUniqueInput;
      create: ProductSpecCreateInput;
      update: ProductSpecUpdateInput;
    }
  ) => ProductSpecPromise;
  deleteProductSpec: (where: ProductSpecWhereUniqueInput) => ProductSpecPromise;
  deleteManyProductSpecs: (
    where?: ProductSpecWhereInput
  ) => BatchPayloadPromise;
  createProductSpecDesc: (
    data: ProductSpecDescCreateInput
  ) => ProductSpecDescPromise;
  updateProductSpecDesc: (
    args: {
      data: ProductSpecDescUpdateInput;
      where: ProductSpecDescWhereUniqueInput;
    }
  ) => ProductSpecDescPromise;
  updateManyProductSpecDescs: (
    args: {
      data: ProductSpecDescUpdateManyMutationInput;
      where?: ProductSpecDescWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductSpecDesc: (
    args: {
      where: ProductSpecDescWhereUniqueInput;
      create: ProductSpecDescCreateInput;
      update: ProductSpecDescUpdateInput;
    }
  ) => ProductSpecDescPromise;
  deleteProductSpecDesc: (
    where: ProductSpecDescWhereUniqueInput
  ) => ProductSpecDescPromise;
  deleteManyProductSpecDescs: (
    where?: ProductSpecDescWhereInput
  ) => BatchPayloadPromise;
  createProductVariant: (
    data: ProductVariantCreateInput
  ) => ProductVariantPromise;
  updateProductVariant: (
    args: {
      data: ProductVariantUpdateInput;
      where: ProductVariantWhereUniqueInput;
    }
  ) => ProductVariantPromise;
  upsertProductVariant: (
    args: {
      where: ProductVariantWhereUniqueInput;
      create: ProductVariantCreateInput;
      update: ProductVariantUpdateInput;
    }
  ) => ProductVariantPromise;
  deleteProductVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  deleteManyProductVariants: (
    where?: ProductVariantWhereInput
  ) => BatchPayloadPromise;
  createProductVariantSpec: (
    data: ProductVariantSpecCreateInput
  ) => ProductVariantSpecPromise;
  updateProductVariantSpec: (
    args: {
      data: ProductVariantSpecUpdateInput;
      where: ProductVariantSpecWhereUniqueInput;
    }
  ) => ProductVariantSpecPromise;
  upsertProductVariantSpec: (
    args: {
      where: ProductVariantSpecWhereUniqueInput;
      create: ProductVariantSpecCreateInput;
      update: ProductVariantSpecUpdateInput;
    }
  ) => ProductVariantSpecPromise;
  deleteProductVariantSpec: (
    where: ProductVariantSpecWhereUniqueInput
  ) => ProductVariantSpecPromise;
  deleteManyProductVariantSpecs: (
    where?: ProductVariantSpecWhereInput
  ) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput }
  ) => ReviewPromise;
  updateManyReviews: (
    args: { data: ReviewUpdateManyMutationInput; where?: ReviewWhereInput }
  ) => BatchPayloadPromise;
  upsertReview: (
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    }
  ) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createStars: (data: StarsCreateInput) => StarsPromise;
  updateStars: (
    args: { data: StarsUpdateInput; where: StarsWhereUniqueInput }
  ) => StarsPromise;
  updateManyStarses: (
    args: { data: StarsUpdateManyMutationInput; where?: StarsWhereInput }
  ) => BatchPayloadPromise;
  upsertStars: (
    args: {
      where: StarsWhereUniqueInput;
      create: StarsCreateInput;
      update: StarsUpdateInput;
    }
  ) => StarsPromise;
  deleteStars: (where: StarsWhereUniqueInput) => StarsPromise;
  deleteManyStarses: (where?: StarsWhereInput) => BatchPayloadPromise;
  createTopPick: (data: TopPickCreateInput) => TopPickPromise;
  updateTopPick: (
    args: { data: TopPickUpdateInput; where: TopPickWhereUniqueInput }
  ) => TopPickPromise;
  updateManyTopPicks: (
    args: { data: TopPickUpdateManyMutationInput; where?: TopPickWhereInput }
  ) => BatchPayloadPromise;
  upsertTopPick: (
    args: {
      where: TopPickWhereUniqueInput;
      create: TopPickCreateInput;
      update: TopPickUpdateInput;
    }
  ) => TopPickPromise;
  deleteTopPick: (where: TopPickWhereUniqueInput) => TopPickPromise;
  deleteManyTopPicks: (where?: TopPickWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVariant: (data: VariantCreateInput) => VariantPromise;
  updateVariant: (
    args: { data: VariantUpdateInput; where: VariantWhereUniqueInput }
  ) => VariantPromise;
  updateManyVariants: (
    args: { data: VariantUpdateManyMutationInput; where?: VariantWhereInput }
  ) => BatchPayloadPromise;
  upsertVariant: (
    args: {
      where: VariantWhereUniqueInput;
      create: VariantCreateInput;
      update: VariantUpdateInput;
    }
  ) => VariantPromise;
  deleteVariant: (where: VariantWhereUniqueInput) => VariantPromise;
  deleteManyVariants: (where?: VariantWhereInput) => BatchPayloadPromise;
  createVote: (data: VoteCreateInput) => VotePromise;
  updateVote: (
    args: { data: VoteUpdateInput; where: VoteWhereUniqueInput }
  ) => VotePromise;
  updateManyVotes: (
    args: { data: VoteUpdateManyMutationInput; where?: VoteWhereInput }
  ) => BatchPayloadPromise;
  upsertVote: (
    args: {
      where: VoteWhereUniqueInput;
      create: VoteCreateInput;
      update: VoteUpdateInput;
    }
  ) => VotePromise;
  deleteVote: (where: VoteWhereUniqueInput) => VotePromise;
  deleteManyVotes: (where?: VoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  banner: (
    where?: BannerSubscriptionWhereInput
  ) => BannerSubscriptionPayloadSubscription;
  bannerImage: (
    where?: BannerImageSubscriptionWhereInput
  ) => BannerImageSubscriptionPayloadSubscription;
  cart: (
    where?: CartSubscriptionWhereInput
  ) => CartSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  popularCategory: (
    where?: PopularCategorySubscriptionWhereInput
  ) => PopularCategorySubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productImage: (
    where?: ProductImageSubscriptionWhereInput
  ) => ProductImageSubscriptionPayloadSubscription;
  productOverviewImage: (
    where?: ProductOverviewImageSubscriptionWhereInput
  ) => ProductOverviewImageSubscriptionPayloadSubscription;
  productOverviewText: (
    where?: ProductOverviewTextSubscriptionWhereInput
  ) => ProductOverviewTextSubscriptionPayloadSubscription;
  productSpec: (
    where?: ProductSpecSubscriptionWhereInput
  ) => ProductSpecSubscriptionPayloadSubscription;
  productSpecDesc: (
    where?: ProductSpecDescSubscriptionWhereInput
  ) => ProductSpecDescSubscriptionPayloadSubscription;
  productVariant: (
    where?: ProductVariantSubscriptionWhereInput
  ) => ProductVariantSubscriptionPayloadSubscription;
  productVariantSpec: (
    where?: ProductVariantSpecSubscriptionWhereInput
  ) => ProductVariantSpecSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  stars: (
    where?: StarsSubscriptionWhereInput
  ) => StarsSubscriptionPayloadSubscription;
  topPick: (
    where?: TopPickSubscriptionWhereInput
  ) => TopPickSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  variant: (
    where?: VariantSubscriptionWhereInput
  ) => VariantSubscriptionPayloadSubscription;
  vote: (
    where?: VoteSubscriptionWhereInput
  ) => VoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PopularCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryKey =
  | "PHONES"
  | "ELECTRONICS"
  | "LAPTOPS"
  | "GROCERIES"
  | "FRESH_FOOD"
  | "FROZEN_FOOD"
  | "APPLIANCES"
  | "FURNITURE"
  | "HOUSEHOLD"
  | "OUTDOOR"
  | "BABY_WORLD"
  | "TOYS"
  | "BEAUTY"
  | "WATCHES";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "categoryKey_ASC"
  | "categoryKey_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "positive_ASC"
  | "positive_DESC"
  | "negative_ASC"
  | "negative_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "qty_ASC"
  | "qty_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopPickOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductSpecDescOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StarsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "one_ASC"
  | "one_DESC"
  | "two_ASC"
  | "two_DESC"
  | "three_ASC"
  | "three_DESC"
  | "four_ASC"
  | "four_DESC"
  | "five_ASC"
  | "five_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductSpecOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BannerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "marketing_ASC"
  | "marketing_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOverviewImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "small_ASC"
  | "small_DESC"
  | "medium_ASC"
  | "medium_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOverviewTextOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariantType = "COLOR" | "SIZE";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "price_ASC"
  | "price_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "discount_ASC"
  | "discount_DESC"
  | "searchString_ASC"
  | "searchString_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BannerImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "alt_ASC"
  | "alt_DESC"
  | "url_ASC"
  | "url_DESC"
  | "css_ASC"
  | "css_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ProductVariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductVariantSpecOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface VariantUpdateWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  data: VariantUpdateDataInput;
}

export type BannerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StarsUpdateOneWithoutProductInput {
  create?: StarsCreateWithoutProductInput;
  update?: StarsUpdateWithoutProductDataInput;
  upsert?: StarsUpsertWithoutProductInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StarsWhereUniqueInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: String;
  brand_not?: String;
  brand_in?: String[] | String;
  brand_not_in?: String[] | String;
  brand_lt?: String;
  brand_lte?: String;
  brand_gt?: String;
  brand_gte?: String;
  brand_contains?: String;
  brand_not_contains?: String;
  brand_starts_with?: String;
  brand_not_starts_with?: String;
  brand_ends_with?: String;
  brand_not_ends_with?: String;
  category?: CategoryWhereInput;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  unit?: String;
  unit_not?: String;
  unit_in?: String[] | String;
  unit_not_in?: String[] | String;
  unit_lt?: String;
  unit_lte?: String;
  unit_gt?: String;
  unit_gte?: String;
  unit_contains?: String;
  unit_not_contains?: String;
  unit_starts_with?: String;
  unit_not_starts_with?: String;
  unit_ends_with?: String;
  unit_not_ends_with?: String;
  discount?: Int;
  discount_not?: Int;
  discount_in?: Int[] | Int;
  discount_not_in?: Int[] | Int;
  discount_lt?: Int;
  discount_lte?: Int;
  discount_gt?: Int;
  discount_gte?: Int;
  images?: ProductImageWhereInput;
  variants?: ProductVariantWhereInput;
  stars?: StarsWhereInput;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  overviewTexts_every?: ProductOverviewTextWhereInput;
  overviewTexts_some?: ProductOverviewTextWhereInput;
  overviewTexts_none?: ProductOverviewTextWhereInput;
  overviewImages_every?: ProductOverviewImageWhereInput;
  overviewImages_some?: ProductOverviewImageWhereInput;
  overviewImages_none?: ProductOverviewImageWhereInput;
  specs_every?: ProductSpecWhereInput;
  specs_some?: ProductSpecWhereInput;
  specs_none?: ProductSpecWhereInput;
  searchString?: String;
  searchString_not?: String;
  searchString_in?: String[] | String;
  searchString_not_in?: String[] | String;
  searchString_lt?: String;
  searchString_lte?: String;
  searchString_gt?: String;
  searchString_gte?: String;
  searchString_contains?: String;
  searchString_not_contains?: String;
  searchString_starts_with?: String;
  searchString_not_starts_with?: String;
  searchString_ends_with?: String;
  searchString_not_ends_with?: String;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface VariantCreateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
}

export interface ProductUpdateOneRequiredWithoutOverviewTextsInput {
  create?: ProductCreateWithoutOverviewTextsInput;
  update?: ProductUpdateWithoutOverviewTextsDataInput;
  upsert?: ProductUpsertWithoutOverviewTextsInput;
  connect?: ProductWhereUniqueInput;
}

export interface VariantCreateInput {
  name: String;
  value: String;
  type?: VariantType;
}

export interface StarsUpdateWithoutProductDataInput {
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface ProductVariantSpecCreateOneWithoutProductVariantInput {
  create?: ProductVariantSpecCreateWithoutProductVariantInput;
  connect?: ProductVariantSpecWhereUniqueInput;
}

export interface VariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  type?: VariantType;
  type_not?: VariantType;
  type_in?: VariantType[] | VariantType;
  type_not_in?: VariantType[] | VariantType;
  AND?: VariantWhereInput[] | VariantWhereInput;
  OR?: VariantWhereInput[] | VariantWhereInput;
  NOT?: VariantWhereInput[] | VariantWhereInput;
}

export interface ProductVariantSpecCreateWithoutProductVariantInput {
  color?: VariantCreateOneInput;
  size?: VariantCreateOneInput;
}

export interface ProductVariantSpecWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  productVariant?: ProductVariantWhereInput;
  color?: VariantWhereInput;
  size?: VariantWhereInput;
  AND?: ProductVariantSpecWhereInput[] | ProductVariantSpecWhereInput;
  OR?: ProductVariantSpecWhereInput[] | ProductVariantSpecWhereInput;
  NOT?: ProductVariantSpecWhereInput[] | ProductVariantSpecWhereInput;
}

export interface VariantCreateOneInput {
  create?: VariantCreateInput;
  connect?: VariantWhereUniqueInput;
}

export interface ProductOverviewTextWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  product?: ProductWhereInput;
  AND?: ProductOverviewTextWhereInput[] | ProductOverviewTextWhereInput;
  OR?: ProductOverviewTextWhereInput[] | ProductOverviewTextWhereInput;
  NOT?: ProductOverviewTextWhereInput[] | ProductOverviewTextWhereInput;
}

export interface StarsCreateOneWithoutProductInput {
  create?: StarsCreateWithoutProductInput;
  connect?: StarsWhereUniqueInput;
}

export interface ProductSpecWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  productSpecDescs_every?: ProductSpecDescWhereInput;
  productSpecDescs_some?: ProductSpecDescWhereInput;
  productSpecDescs_none?: ProductSpecDescWhereInput;
  product?: ProductWhereInput;
  AND?: ProductSpecWhereInput[] | ProductSpecWhereInput;
  OR?: ProductSpecWhereInput[] | ProductSpecWhereInput;
  NOT?: ProductSpecWhereInput[] | ProductSpecWhereInput;
}

export interface StarsCreateWithoutProductInput {
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ProductOverviewTextCreateManyWithoutProductInput {
  create?:
    | ProductOverviewTextCreateWithoutProductInput[]
    | ProductOverviewTextCreateWithoutProductInput;
  connect?:
    | ProductOverviewTextWhereUniqueInput[]
    | ProductOverviewTextWhereUniqueInput;
}

export interface VoteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VoteWhereInput;
  AND?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
  OR?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
  NOT?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
}

export interface ProductOverviewTextCreateWithoutProductInput {
  text?: String;
  pairs?: ProductOverviewTextCreatepairsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ProductOverviewTextCreatepairsInput {
  set?: String[] | String;
}

export interface StarsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StarsWhereInput;
  AND?: StarsSubscriptionWhereInput[] | StarsSubscriptionWhereInput;
  OR?: StarsSubscriptionWhereInput[] | StarsSubscriptionWhereInput;
  NOT?: StarsSubscriptionWhereInput[] | StarsSubscriptionWhereInput;
}

export interface ProductOverviewImageCreateManyWithoutProductInput {
  create?:
    | ProductOverviewImageCreateWithoutProductInput[]
    | ProductOverviewImageCreateWithoutProductInput;
  connect?:
    | ProductOverviewImageWhereUniqueInput[]
    | ProductOverviewImageWhereUniqueInput;
}

export interface ProductVariantSpecSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductVariantSpecWhereInput;
  AND?:
    | ProductVariantSpecSubscriptionWhereInput[]
    | ProductVariantSpecSubscriptionWhereInput;
  OR?:
    | ProductVariantSpecSubscriptionWhereInput[]
    | ProductVariantSpecSubscriptionWhereInput;
  NOT?:
    | ProductVariantSpecSubscriptionWhereInput[]
    | ProductVariantSpecSubscriptionWhereInput;
}

export interface ProductOverviewImageCreateWithoutProductInput {
  label?: String;
  image?: String;
}

export interface ProductVariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductVariantWhereInput;
  AND?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
  OR?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
  NOT?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
}

export interface ProductSpecCreateManyWithoutProductInput {
  create?:
    | ProductSpecCreateWithoutProductInput[]
    | ProductSpecCreateWithoutProductInput;
  connect?: ProductSpecWhereUniqueInput[] | ProductSpecWhereUniqueInput;
}

export interface ProductSpecSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductSpecWhereInput;
  AND?: ProductSpecSubscriptionWhereInput[] | ProductSpecSubscriptionWhereInput;
  OR?: ProductSpecSubscriptionWhereInput[] | ProductSpecSubscriptionWhereInput;
  NOT?: ProductSpecSubscriptionWhereInput[] | ProductSpecSubscriptionWhereInput;
}

export interface ProductSpecCreateWithoutProductInput {
  title: String;
  badges?: ProductSpecCreatebadgesInput;
  productSpecDescs?: ProductSpecDescCreateManyWithoutProductSpecInput;
}

export interface ProductOverviewImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductOverviewImageWhereInput;
  AND?:
    | ProductOverviewImageSubscriptionWhereInput[]
    | ProductOverviewImageSubscriptionWhereInput;
  OR?:
    | ProductOverviewImageSubscriptionWhereInput[]
    | ProductOverviewImageSubscriptionWhereInput;
  NOT?:
    | ProductOverviewImageSubscriptionWhereInput[]
    | ProductOverviewImageSubscriptionWhereInput;
}

export interface ProductSpecCreatebadgesInput {
  set?: String[] | String;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface ProductSpecDescCreateManyWithoutProductSpecInput {
  create?:
    | ProductSpecDescCreateWithoutProductSpecInput[]
    | ProductSpecDescCreateWithoutProductSpecInput;
  connect?: ProductSpecDescWhereUniqueInput[] | ProductSpecDescWhereUniqueInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface ProductSpecDescCreateWithoutProductSpecInput {
  title?: String;
  texts?: ProductSpecDescCreatetextsInput;
}

export interface CartSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CartWhereInput;
  AND?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
  OR?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
  NOT?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
}

export interface ProductSpecDescCreatetextsInput {
  set?: String[] | String;
}

export interface CartWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  product?: ProductWhereInput;
  qty?: Int;
  qty_not?: Int;
  qty_in?: Int[] | Int;
  qty_not_in?: Int[] | Int;
  qty_lt?: Int;
  qty_lte?: Int;
  qty_gt?: Int;
  qty_gte?: Int;
  AND?: CartWhereInput[] | CartWhereInput;
  OR?: CartWhereInput[] | CartWhereInput;
  NOT?: CartWhereInput[] | CartWhereInput;
}

export interface VoteCreateOneWithoutReviewInput {
  create?: VoteCreateWithoutReviewInput;
  connect?: VoteWhereUniqueInput;
}

export interface VoteUpdateManyMutationInput {
  positive?: Int;
  negative?: Int;
}

export interface VoteCreateWithoutReviewInput {
  positive?: Int;
  negative?: Int;
}

export interface ReviewUpdateWithoutVotesDataInput {
  title?: String;
  description?: String;
  product?: ProductUpdateOneRequiredWithoutReviewsInput;
  author?: UserUpdateOneWithoutReviewsInput;
}

export interface ProductCreateOneInput {
  create?: ProductCreateInput;
  connect?: ProductWhereUniqueInput;
}

export interface ReviewUpdateOneWithoutVotesInput {
  create?: ReviewCreateWithoutVotesInput;
  update?: ReviewUpdateWithoutVotesDataInput;
  upsert?: ReviewUpsertWithoutVotesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ReviewWhereUniqueInput;
}

export interface ProductCreateInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface ReviewCreateWithoutVotesInput {
  title?: String;
  description?: String;
  product: ProductCreateOneWithoutReviewsInput;
  author?: UserCreateOneWithoutReviewsInput;
}

export interface ReviewCreateManyWithoutProductInput {
  create?: ReviewCreateWithoutProductInput[] | ReviewCreateWithoutProductInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export type PopularCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewCreateWithoutProductInput {
  title?: String;
  description?: String;
  author?: UserCreateOneWithoutReviewsInput;
  votes?: VoteCreateOneWithoutReviewInput;
}

export interface PopularCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: CategoryWhereInput;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  AND?: PopularCategoryWhereInput[] | PopularCategoryWhereInput;
  OR?: PopularCategoryWhereInput[] | PopularCategoryWhereInput;
  NOT?: PopularCategoryWhereInput[] | PopularCategoryWhereInput;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface VariantUpdateInput {
  name?: String;
  value?: String;
  type?: VariantType;
}

export interface UserCreateWithoutReviewsInput {
  email: String;
  password: String;
  name: String;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  name?: String;
  reviews?: ReviewUpdateManyWithoutAuthorInput;
}

export interface CartUpdateInput {
  user?: UserUpdateOneRequiredInput;
  product?: ProductUpdateOneRequiredInput;
  qty?: Int;
}

export interface TopPickUpdateManyMutationInput {
  name?: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface UserUpdateDataInput {
  email?: String;
  password?: String;
  name?: String;
  reviews?: ReviewUpdateManyWithoutAuthorInput;
}

export interface ProductUpdateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  update?:
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ReviewUpdateManyWithoutAuthorInput {
  create?: ReviewCreateWithoutAuthorInput[] | ReviewCreateWithoutAuthorInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    | ReviewUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    | ReviewUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export interface ProductCreateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutAuthorDataInput;
}

export type ProductOverviewImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateWithoutAuthorDataInput {
  title?: String;
  description?: String;
  product?: ProductUpdateOneRequiredWithoutReviewsInput;
  votes?: VoteUpdateOneWithoutReviewInput;
}

export interface ProductUpsertWithoutStarsInput {
  update: ProductUpdateWithoutStarsDataInput;
  create: ProductCreateWithoutStarsInput;
}

export interface ProductUpdateOneRequiredWithoutReviewsInput {
  create?: ProductCreateWithoutReviewsInput;
  update?: ProductUpdateWithoutReviewsDataInput;
  upsert?: ProductUpsertWithoutReviewsInput;
  connect?: ProductWhereUniqueInput;
}

export type ProductOverviewTextWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateWithoutReviewsDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface StarsUpdateInput {
  product?: ProductUpdateOneRequiredWithoutStarsInput;
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface CategoryUpdateOneWithoutProductsInput {
  create?: CategoryCreateWithoutProductsInput;
  update?: CategoryUpdateWithoutProductsDataInput;
  upsert?: CategoryUpsertWithoutProductsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CategoryWhereUniqueInput;
}

export type ProductSpecWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoryUpdateWithoutProductsDataInput {
  categoryKey?: CategoryKey;
  name?: String;
  subCategories?: CategoryUpdatesubCategoriesInput;
}

export interface StarsCreateInput {
  product: ProductCreateOneWithoutStarsInput;
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface CategoryUpdatesubCategoriesInput {
  set?: String[] | String;
}

export type ProductSpecDescWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoryUpsertWithoutProductsInput {
  update: CategoryUpdateWithoutProductsDataInput;
  create: CategoryCreateWithoutProductsInput;
}

export interface ReviewCreateInput {
  title?: String;
  description?: String;
  product: ProductCreateOneWithoutReviewsInput;
  author?: UserCreateOneWithoutReviewsInput;
  votes?: VoteCreateOneWithoutReviewInput;
}

export interface ProductImageUpdateOneWithoutProductInput {
  create?: ProductImageCreateWithoutProductInput;
  update?: ProductImageUpdateWithoutProductDataInput;
  upsert?: ProductImageUpsertWithoutProductInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductImageWhereUniqueInput;
}

export type ProductVariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductImageUpdateWithoutProductDataInput {
  small?: String;
  medium?: String;
  large?: ProductImageUpdatelargeInput;
}

export interface ProductVariantUpdateOneRequiredWithoutSpecsInput {
  create?: ProductVariantCreateWithoutSpecsInput;
  update?: ProductVariantUpdateWithoutSpecsDataInput;
  upsert?: ProductVariantUpsertWithoutSpecsInput;
  connect?: ProductVariantWhereUniqueInput;
}

export interface ProductImageUpdatelargeInput {
  set?: String[] | String;
}

export interface ProductVariantCreateWithoutSpecsInput {
  product: ProductCreateOneWithoutVariantsInput;
  colors?: VariantCreateManyInput;
  sizes?: VariantCreateManyInput;
}

export interface ProductImageUpsertWithoutProductInput {
  update: ProductImageUpdateWithoutProductDataInput;
  create: ProductImageCreateWithoutProductInput;
}

export interface ProductVariantCreateOneWithoutSpecsInput {
  create?: ProductVariantCreateWithoutSpecsInput;
  connect?: ProductVariantWhereUniqueInput;
}

export interface ProductUpdatebadgesInput {
  set?: String[] | String;
}

export interface ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput;
  create: ProductCreateWithoutVariantsInput;
}

export interface ProductUpdatemiscsInput {
  set?: String[] | String;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductVariantUpdateOneWithoutProductInput {
  create?: ProductVariantCreateWithoutProductInput;
  update?: ProductVariantUpdateWithoutProductDataInput;
  upsert?: ProductVariantUpsertWithoutProductInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductVariantWhereUniqueInput;
}

export interface ProductVariantUpdateInput {
  product?: ProductUpdateOneRequiredWithoutVariantsInput;
  colors?: VariantUpdateManyInput;
  sizes?: VariantUpdateManyInput;
  specs?: ProductVariantSpecUpdateOneWithoutProductVariantInput;
}

export interface ProductVariantUpdateWithoutProductDataInput {
  colors?: VariantUpdateManyInput;
  sizes?: VariantUpdateManyInput;
  specs?: ProductVariantSpecUpdateOneWithoutProductVariantInput;
}

export type StarsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VariantUpdateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  update?:
    | VariantUpdateWithWhereUniqueNestedInput[]
    | VariantUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VariantUpsertWithWhereUniqueNestedInput[]
    | VariantUpsertWithWhereUniqueNestedInput;
  delete?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  disconnect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  deleteMany?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  updateMany?:
    | VariantUpdateManyWithWhereNestedInput[]
    | VariantUpdateManyWithWhereNestedInput;
}

export interface ProductVariantCreateInput {
  product: ProductCreateOneWithoutVariantsInput;
  colors?: VariantCreateManyInput;
  sizes?: VariantCreateManyInput;
  specs?: ProductVariantSpecCreateOneWithoutProductVariantInput;
}

export interface ProductUpdateWithoutOverviewTextsDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductSpecUpsertWithoutProductSpecDescsInput {
  update: ProductSpecUpdateWithoutProductSpecDescsDataInput;
  create: ProductSpecCreateWithoutProductSpecDescsInput;
}

export interface VariantUpdateDataInput {
  name?: String;
  value?: String;
  type?: VariantType;
}

export interface ProductSpecUpdateWithoutProductSpecDescsDataInput {
  title?: String;
  badges?: ProductSpecUpdatebadgesInput;
  product?: ProductUpdateOneRequiredWithoutSpecsInput;
}

export interface VariantUpsertWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface BannerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  marketing?: String;
  marketing_not?: String;
  marketing_in?: String[] | String;
  marketing_not_in?: String[] | String;
  marketing_lt?: String;
  marketing_lte?: String;
  marketing_gt?: String;
  marketing_gte?: String;
  marketing_contains?: String;
  marketing_not_contains?: String;
  marketing_starts_with?: String;
  marketing_not_starts_with?: String;
  marketing_ends_with?: String;
  marketing_not_ends_with?: String;
  images_every?: BannerImageWhereInput;
  images_some?: BannerImageWhereInput;
  images_none?: BannerImageWhereInput;
  AND?: BannerWhereInput[] | BannerWhereInput;
  OR?: BannerWhereInput[] | BannerWhereInput;
  NOT?: BannerWhereInput[] | BannerWhereInput;
}

export interface VariantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  type?: VariantType;
  type_not?: VariantType;
  type_in?: VariantType[] | VariantType;
  type_not_in?: VariantType[] | VariantType;
  AND?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  OR?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  NOT?: VariantScalarWhereInput[] | VariantScalarWhereInput;
}

export interface ProductSpecDescUpdateInput {
  title?: String;
  texts?: ProductSpecDescUpdatetextsInput;
  productSpec?: ProductSpecUpdateOneRequiredWithoutProductSpecDescsInput;
}

export interface VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput;
  data: VariantUpdateManyDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface VariantUpdateManyDataInput {
  name?: String;
  value?: String;
  type?: VariantType;
}

export interface ProductSpecCreateOneWithoutProductSpecDescsInput {
  create?: ProductSpecCreateWithoutProductSpecDescsInput;
  connect?: ProductSpecWhereUniqueInput;
}

export interface ProductVariantSpecUpdateOneWithoutProductVariantInput {
  create?: ProductVariantSpecCreateWithoutProductVariantInput;
  update?: ProductVariantSpecUpdateWithoutProductVariantDataInput;
  upsert?: ProductVariantSpecUpsertWithoutProductVariantInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductVariantSpecWhereUniqueInput;
}

export interface ProductSpecUpdateManyMutationInput {
  title?: String;
  badges?: ProductSpecUpdatebadgesInput;
}

export interface ProductVariantSpecUpdateWithoutProductVariantDataInput {
  color?: VariantUpdateOneInput;
  size?: VariantUpdateOneInput;
}

export interface ProductUpsertWithoutSpecsInput {
  update: ProductUpdateWithoutSpecsDataInput;
  create: ProductCreateWithoutSpecsInput;
}

export interface VariantUpdateOneInput {
  create?: VariantCreateInput;
  update?: VariantUpdateDataInput;
  upsert?: VariantUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VariantWhereUniqueInput;
}

export interface ProductUpdateOneRequiredWithoutSpecsInput {
  create?: ProductCreateWithoutSpecsInput;
  update?: ProductUpdateWithoutSpecsDataInput;
  upsert?: ProductUpsertWithoutSpecsInput;
  connect?: ProductWhereUniqueInput;
}

export interface VariantUpsertNestedInput {
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface ProductSpecUpdateInput {
  title?: String;
  badges?: ProductSpecUpdatebadgesInput;
  productSpecDescs?: ProductSpecDescUpdateManyWithoutProductSpecInput;
  product?: ProductUpdateOneRequiredWithoutSpecsInput;
}

export interface ProductVariantSpecUpsertWithoutProductVariantInput {
  update: ProductVariantSpecUpdateWithoutProductVariantDataInput;
  create: ProductVariantSpecCreateWithoutProductVariantInput;
}

export interface ProductCreateOneWithoutSpecsInput {
  create?: ProductCreateWithoutSpecsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductVariantUpsertWithoutProductInput {
  update: ProductVariantUpdateWithoutProductDataInput;
  create: ProductVariantCreateWithoutProductInput;
}

export interface BannerImageCreateManyWithoutBannerInput {
  create?:
    | BannerImageCreateWithoutBannerInput[]
    | BannerImageCreateWithoutBannerInput;
  connect?: BannerImageWhereUniqueInput[] | BannerImageWhereUniqueInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  categoryKey?: CategoryKey;
  categoryKey_not?: CategoryKey;
  categoryKey_in?: CategoryKey[] | CategoryKey;
  categoryKey_not_in?: CategoryKey[] | CategoryKey;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface BannerUpdateInput {
  marketing?: String;
  images?: BannerImageUpdateManyWithoutBannerInput;
}

export interface ProductImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  small?: String;
  small_not?: String;
  small_in?: String[] | String;
  small_not_in?: String[] | String;
  small_lt?: String;
  small_lte?: String;
  small_gt?: String;
  small_gte?: String;
  small_contains?: String;
  small_not_contains?: String;
  small_starts_with?: String;
  small_not_starts_with?: String;
  small_ends_with?: String;
  small_not_ends_with?: String;
  medium?: String;
  medium_not?: String;
  medium_in?: String[] | String;
  medium_not_in?: String[] | String;
  medium_lt?: String;
  medium_lte?: String;
  medium_gt?: String;
  medium_gte?: String;
  medium_contains?: String;
  medium_not_contains?: String;
  medium_starts_with?: String;
  medium_not_starts_with?: String;
  medium_ends_with?: String;
  medium_not_ends_with?: String;
  AND?: ProductImageWhereInput[] | ProductImageWhereInput;
  OR?: ProductImageWhereInput[] | ProductImageWhereInput;
  NOT?: ProductImageWhereInput[] | ProductImageWhereInput;
}

export interface BannerImageUpdateWithWhereUniqueWithoutBannerInput {
  where: BannerImageWhereUniqueInput;
  data: BannerImageUpdateWithoutBannerDataInput;
}

export interface StarsUpsertWithoutProductInput {
  update: StarsUpdateWithoutProductDataInput;
  create: StarsCreateWithoutProductInput;
}

export interface BannerImageUpsertWithWhereUniqueWithoutBannerInput {
  where: BannerImageWhereUniqueInput;
  update: BannerImageUpdateWithoutBannerDataInput;
  create: BannerImageCreateWithoutBannerInput;
}

export interface ProductOverviewTextUpdateManyWithoutProductInput {
  create?:
    | ProductOverviewTextCreateWithoutProductInput[]
    | ProductOverviewTextCreateWithoutProductInput;
  delete?:
    | ProductOverviewTextWhereUniqueInput[]
    | ProductOverviewTextWhereUniqueInput;
  connect?:
    | ProductOverviewTextWhereUniqueInput[]
    | ProductOverviewTextWhereUniqueInput;
  disconnect?:
    | ProductOverviewTextWhereUniqueInput[]
    | ProductOverviewTextWhereUniqueInput;
  update?:
    | ProductOverviewTextUpdateWithWhereUniqueWithoutProductInput[]
    | ProductOverviewTextUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ProductOverviewTextUpsertWithWhereUniqueWithoutProductInput[]
    | ProductOverviewTextUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?:
    | ProductOverviewTextScalarWhereInput[]
    | ProductOverviewTextScalarWhereInput;
  updateMany?:
    | ProductOverviewTextUpdateManyWithWhereNestedInput[]
    | ProductOverviewTextUpdateManyWithWhereNestedInput;
}

export interface BannerImageUpdateManyWithWhereNestedInput {
  where: BannerImageScalarWhereInput;
  data: BannerImageUpdateManyDataInput;
}

export interface ProductOverviewTextUpdateWithWhereUniqueWithoutProductInput {
  where: ProductOverviewTextWhereUniqueInput;
  data: ProductOverviewTextUpdateWithoutProductDataInput;
}

export interface BannerUpdateManyMutationInput {
  marketing?: String;
}

export interface ProductOverviewTextUpdateWithoutProductDataInput {
  text?: String;
  pairs?: ProductOverviewTextUpdatepairsInput;
}

export interface ProductUpsertWithoutOverviewTextsInput {
  update: ProductUpdateWithoutOverviewTextsDataInput;
  create: ProductCreateWithoutOverviewTextsInput;
}

export interface ProductOverviewTextUpdatepairsInput {
  set?: String[] | String;
}

export interface BannerCreateOneWithoutImagesInput {
  create?: BannerCreateWithoutImagesInput;
  connect?: BannerWhereUniqueInput;
}

export interface ProductOverviewTextUpsertWithWhereUniqueWithoutProductInput {
  where: ProductOverviewTextWhereUniqueInput;
  update: ProductOverviewTextUpdateWithoutProductDataInput;
  create: ProductOverviewTextCreateWithoutProductInput;
}

export interface BannerImageUpdateInput {
  banner?: BannerUpdateOneRequiredWithoutImagesInput;
  image?: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface ProductOverviewTextScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?:
    | ProductOverviewTextScalarWhereInput[]
    | ProductOverviewTextScalarWhereInput;
  OR?:
    | ProductOverviewTextScalarWhereInput[]
    | ProductOverviewTextScalarWhereInput;
  NOT?:
    | ProductOverviewTextScalarWhereInput[]
    | ProductOverviewTextScalarWhereInput;
}

export interface BannerUpdateWithoutImagesDataInput {
  marketing?: String;
}

export interface ProductOverviewTextUpdateManyWithWhereNestedInput {
  where: ProductOverviewTextScalarWhereInput;
  data: ProductOverviewTextUpdateManyDataInput;
}

export interface BannerImageUpdateManyMutationInput {
  image?: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface ProductOverviewTextUpdateManyDataInput {
  text?: String;
  pairs?: ProductOverviewTextUpdatepairsInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface ProductOverviewImageUpdateManyWithoutProductInput {
  create?:
    | ProductOverviewImageCreateWithoutProductInput[]
    | ProductOverviewImageCreateWithoutProductInput;
  delete?:
    | ProductOverviewImageWhereUniqueInput[]
    | ProductOverviewImageWhereUniqueInput;
  connect?:
    | ProductOverviewImageWhereUniqueInput[]
    | ProductOverviewImageWhereUniqueInput;
  disconnect?:
    | ProductOverviewImageWhereUniqueInput[]
    | ProductOverviewImageWhereUniqueInput;
  update?:
    | ProductOverviewImageUpdateWithWhereUniqueWithoutProductInput[]
    | ProductOverviewImageUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ProductOverviewImageUpsertWithWhereUniqueWithoutProductInput[]
    | ProductOverviewImageUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?:
    | ProductOverviewImageScalarWhereInput[]
    | ProductOverviewImageScalarWhereInput;
  updateMany?:
    | ProductOverviewImageUpdateManyWithWhereNestedInput[]
    | ProductOverviewImageUpdateManyWithWhereNestedInput;
}

export interface ReviewCreateManyWithoutAuthorInput {
  create?: ReviewCreateWithoutAuthorInput[] | ReviewCreateWithoutAuthorInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface ProductOverviewImageUpdateWithWhereUniqueWithoutProductInput {
  where: ProductOverviewImageWhereUniqueInput;
  data: ProductOverviewImageUpdateWithoutProductDataInput;
}

export interface ProductCreateOneWithoutReviewsInput {
  create?: ProductCreateWithoutReviewsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductOverviewImageUpdateWithoutProductDataInput {
  label?: String;
  image?: String;
}

export interface CategoryCreateOneWithoutProductsInput {
  create?: CategoryCreateWithoutProductsInput;
  connect?: CategoryWhereUniqueInput;
}

export interface ProductOverviewImageUpsertWithWhereUniqueWithoutProductInput {
  where: ProductOverviewImageWhereUniqueInput;
  update: ProductOverviewImageUpdateWithoutProductDataInput;
  create: ProductOverviewImageCreateWithoutProductInput;
}

export interface CategoryCreatesubCategoriesInput {
  set?: String[] | String;
}

export interface ProductOverviewImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  AND?:
    | ProductOverviewImageScalarWhereInput[]
    | ProductOverviewImageScalarWhereInput;
  OR?:
    | ProductOverviewImageScalarWhereInput[]
    | ProductOverviewImageScalarWhereInput;
  NOT?:
    | ProductOverviewImageScalarWhereInput[]
    | ProductOverviewImageScalarWhereInput;
}

export interface ProductImageCreateWithoutProductInput {
  small?: String;
  medium?: String;
  large?: ProductImageCreatelargeInput;
}

export interface ProductOverviewImageUpdateManyWithWhereNestedInput {
  where: ProductOverviewImageScalarWhereInput;
  data: ProductOverviewImageUpdateManyDataInput;
}

export interface ProductCreatebadgesInput {
  set?: String[] | String;
}

export interface ProductOverviewImageUpdateManyDataInput {
  label?: String;
  image?: String;
}

export interface ProductVariantCreateOneWithoutProductInput {
  create?: ProductVariantCreateWithoutProductInput;
  connect?: ProductVariantWhereUniqueInput;
}

export interface ProductSpecUpdateManyWithoutProductInput {
  create?:
    | ProductSpecCreateWithoutProductInput[]
    | ProductSpecCreateWithoutProductInput;
  delete?: ProductSpecWhereUniqueInput[] | ProductSpecWhereUniqueInput;
  connect?: ProductSpecWhereUniqueInput[] | ProductSpecWhereUniqueInput;
  disconnect?: ProductSpecWhereUniqueInput[] | ProductSpecWhereUniqueInput;
  update?:
    | ProductSpecUpdateWithWhereUniqueWithoutProductInput[]
    | ProductSpecUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ProductSpecUpsertWithWhereUniqueWithoutProductInput[]
    | ProductSpecUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?: ProductSpecScalarWhereInput[] | ProductSpecScalarWhereInput;
  updateMany?:
    | ProductSpecUpdateManyWithWhereNestedInput[]
    | ProductSpecUpdateManyWithWhereNestedInput;
}

export interface ProductVariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  colors_every?: VariantWhereInput;
  colors_some?: VariantWhereInput;
  colors_none?: VariantWhereInput;
  sizes_every?: VariantWhereInput;
  sizes_some?: VariantWhereInput;
  sizes_none?: VariantWhereInput;
  specs?: ProductVariantSpecWhereInput;
  AND?: ProductVariantWhereInput[] | ProductVariantWhereInput;
  OR?: ProductVariantWhereInput[] | ProductVariantWhereInput;
  NOT?: ProductVariantWhereInput[] | ProductVariantWhereInput;
}

export interface ProductSpecUpdateWithWhereUniqueWithoutProductInput {
  where: ProductSpecWhereUniqueInput;
  data: ProductSpecUpdateWithoutProductDataInput;
}

export interface StarsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  one?: Int;
  one_not?: Int;
  one_in?: Int[] | Int;
  one_not_in?: Int[] | Int;
  one_lt?: Int;
  one_lte?: Int;
  one_gt?: Int;
  one_gte?: Int;
  two?: Int;
  two_not?: Int;
  two_in?: Int[] | Int;
  two_not_in?: Int[] | Int;
  two_lt?: Int;
  two_lte?: Int;
  two_gt?: Int;
  two_gte?: Int;
  three?: Int;
  three_not?: Int;
  three_in?: Int[] | Int;
  three_not_in?: Int[] | Int;
  three_lt?: Int;
  three_lte?: Int;
  three_gt?: Int;
  three_gte?: Int;
  four?: Int;
  four_not?: Int;
  four_in?: Int[] | Int;
  four_not_in?: Int[] | Int;
  four_lt?: Int;
  four_lte?: Int;
  four_gt?: Int;
  four_gte?: Int;
  five?: Int;
  five_not?: Int;
  five_in?: Int[] | Int;
  five_not_in?: Int[] | Int;
  five_lt?: Int;
  five_lte?: Int;
  five_gt?: Int;
  five_gte?: Int;
  AND?: StarsWhereInput[] | StarsWhereInput;
  OR?: StarsWhereInput[] | StarsWhereInput;
  NOT?: StarsWhereInput[] | StarsWhereInput;
}

export interface ProductSpecUpdateWithoutProductDataInput {
  title?: String;
  badges?: ProductSpecUpdatebadgesInput;
  productSpecDescs?: ProductSpecDescUpdateManyWithoutProductSpecInput;
}

export interface ProductSpecDescWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  productSpec?: ProductSpecWhereInput;
  AND?: ProductSpecDescWhereInput[] | ProductSpecDescWhereInput;
  OR?: ProductSpecDescWhereInput[] | ProductSpecDescWhereInput;
  NOT?: ProductSpecDescWhereInput[] | ProductSpecDescWhereInput;
}

export interface ProductSpecUpdatebadgesInput {
  set?: String[] | String;
}

export interface VariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VariantWhereInput;
  AND?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  OR?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  NOT?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
}

export interface ProductSpecDescUpdateManyWithoutProductSpecInput {
  create?:
    | ProductSpecDescCreateWithoutProductSpecInput[]
    | ProductSpecDescCreateWithoutProductSpecInput;
  delete?: ProductSpecDescWhereUniqueInput[] | ProductSpecDescWhereUniqueInput;
  connect?: ProductSpecDescWhereUniqueInput[] | ProductSpecDescWhereUniqueInput;
  disconnect?:
    | ProductSpecDescWhereUniqueInput[]
    | ProductSpecDescWhereUniqueInput;
  update?:
    | ProductSpecDescUpdateWithWhereUniqueWithoutProductSpecInput[]
    | ProductSpecDescUpdateWithWhereUniqueWithoutProductSpecInput;
  upsert?:
    | ProductSpecDescUpsertWithWhereUniqueWithoutProductSpecInput[]
    | ProductSpecDescUpsertWithWhereUniqueWithoutProductSpecInput;
  deleteMany?:
    | ProductSpecDescScalarWhereInput[]
    | ProductSpecDescScalarWhereInput;
  updateMany?:
    | ProductSpecDescUpdateManyWithWhereNestedInput[]
    | ProductSpecDescUpdateManyWithWhereNestedInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface ProductSpecDescUpdateWithWhereUniqueWithoutProductSpecInput {
  where: ProductSpecDescWhereUniqueInput;
  data: ProductSpecDescUpdateWithoutProductSpecDataInput;
}

export interface ProductSpecDescSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductSpecDescWhereInput;
  AND?:
    | ProductSpecDescSubscriptionWhereInput[]
    | ProductSpecDescSubscriptionWhereInput;
  OR?:
    | ProductSpecDescSubscriptionWhereInput[]
    | ProductSpecDescSubscriptionWhereInput;
  NOT?:
    | ProductSpecDescSubscriptionWhereInput[]
    | ProductSpecDescSubscriptionWhereInput;
}

export interface ProductSpecDescUpdateWithoutProductSpecDataInput {
  title?: String;
  texts?: ProductSpecDescUpdatetextsInput;
}

export interface ProductImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductImageWhereInput;
  AND?:
    | ProductImageSubscriptionWhereInput[]
    | ProductImageSubscriptionWhereInput;
  OR?:
    | ProductImageSubscriptionWhereInput[]
    | ProductImageSubscriptionWhereInput;
  NOT?:
    | ProductImageSubscriptionWhereInput[]
    | ProductImageSubscriptionWhereInput;
}

export interface ProductSpecDescUpdatetextsInput {
  set?: String[] | String;
}

export type BannerImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductSpecDescUpsertWithWhereUniqueWithoutProductSpecInput {
  where: ProductSpecDescWhereUniqueInput;
  update: ProductSpecDescUpdateWithoutProductSpecDataInput;
  create: ProductSpecDescCreateWithoutProductSpecInput;
}

export interface BannerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BannerWhereInput;
  AND?: BannerSubscriptionWhereInput[] | BannerSubscriptionWhereInput;
  OR?: BannerSubscriptionWhereInput[] | BannerSubscriptionWhereInput;
  NOT?: BannerSubscriptionWhereInput[] | BannerSubscriptionWhereInput;
}

export interface ProductSpecDescScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: ProductSpecDescScalarWhereInput[] | ProductSpecDescScalarWhereInput;
  OR?: ProductSpecDescScalarWhereInput[] | ProductSpecDescScalarWhereInput;
  NOT?: ProductSpecDescScalarWhereInput[] | ProductSpecDescScalarWhereInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  categoryKey?: CategoryKey;
}>;

export interface ProductSpecDescUpdateManyWithWhereNestedInput {
  where: ProductSpecDescScalarWhereInput;
  data: ProductSpecDescUpdateManyDataInput;
}

export interface ReviewCreateOneWithoutVotesInput {
  create?: ReviewCreateWithoutVotesInput;
  connect?: ReviewWhereUniqueInput;
}

export interface ProductSpecDescUpdateManyDataInput {
  title?: String;
  texts?: ProductSpecDescUpdatetextsInput;
}

export interface VariantUpdateManyMutationInput {
  name?: String;
  value?: String;
  type?: VariantType;
}

export interface ProductSpecUpsertWithWhereUniqueWithoutProductInput {
  where: ProductSpecWhereUniqueInput;
  update: ProductSpecUpdateWithoutProductDataInput;
  create: ProductSpecCreateWithoutProductInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductSpecScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: ProductSpecScalarWhereInput[] | ProductSpecScalarWhereInput;
  OR?: ProductSpecScalarWhereInput[] | ProductSpecScalarWhereInput;
  NOT?: ProductSpecScalarWhereInput[] | ProductSpecScalarWhereInput;
}

export type ProductImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductSpecUpdateManyWithWhereNestedInput {
  where: ProductSpecScalarWhereInput;
  data: ProductSpecUpdateManyDataInput;
}

export interface TopPickCreateInput {
  name: String;
  products?: ProductCreateManyInput;
}

export interface ProductSpecUpdateManyDataInput {
  title?: String;
  badges?: ProductSpecUpdatebadgesInput;
}

export interface ProductUpdateWithoutStarsDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductUpsertWithoutReviewsInput {
  update: ProductUpdateWithoutReviewsDataInput;
  create: ProductCreateWithoutReviewsInput;
}

export interface ProductCreateWithoutStarsInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface VoteUpdateOneWithoutReviewInput {
  create?: VoteCreateWithoutReviewInput;
  update?: VoteUpdateWithoutReviewDataInput;
  upsert?: VoteUpsertWithoutReviewInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VoteWhereUniqueInput;
}

export interface ReviewUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface VoteUpdateWithoutReviewDataInput {
  positive?: Int;
  negative?: Int;
}

export interface ProductVariantUpsertWithoutSpecsInput {
  update: ProductVariantUpdateWithoutSpecsDataInput;
  create: ProductVariantCreateWithoutSpecsInput;
}

export interface VoteUpsertWithoutReviewInput {
  update: VoteUpdateWithoutReviewDataInput;
  create: VoteCreateWithoutReviewInput;
}

export interface ProductVariantSpecUpdateInput {
  productVariant?: ProductVariantUpdateOneRequiredWithoutSpecsInput;
  color?: VariantUpdateOneInput;
  size?: VariantUpdateOneInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutAuthorDataInput;
  create: ReviewCreateWithoutAuthorInput;
}

export interface ProductVariantSpecCreateInput {
  productVariant: ProductVariantCreateOneWithoutSpecsInput;
  color?: VariantCreateOneInput;
  size?: VariantCreateOneInput;
}

export interface ReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  OR?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  NOT?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
}

export interface ProductUpdateOneRequiredWithoutVariantsInput {
  create?: ProductCreateWithoutVariantsInput;
  update?: ProductUpdateWithoutVariantsDataInput;
  upsert?: ProductUpsertWithoutVariantsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface ProductCreateOneWithoutVariantsInput {
  create?: ProductCreateWithoutVariantsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ReviewUpdateManyDataInput {
  title?: String;
  description?: String;
}

export type TopPickWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ProductSpecUpdateOneRequiredWithoutProductSpecDescsInput {
  create?: ProductSpecCreateWithoutProductSpecDescsInput;
  update?: ProductSpecUpdateWithoutProductSpecDescsDataInput;
  upsert?: ProductSpecUpsertWithoutProductSpecDescsInput;
  connect?: ProductSpecWhereUniqueInput;
}

export interface ProductUpdateOneRequiredInput {
  create?: ProductCreateInput;
  update?: ProductUpdateDataInput;
  upsert?: ProductUpsertNestedInput;
  connect?: ProductWhereUniqueInput;
}

export interface BannerImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  banner?: BannerWhereInput;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  css?: String;
  css_not?: String;
  css_in?: String[] | String;
  css_not_in?: String[] | String;
  css_lt?: String;
  css_lte?: String;
  css_gt?: String;
  css_gte?: String;
  css_contains?: String;
  css_not_contains?: String;
  css_starts_with?: String;
  css_not_starts_with?: String;
  css_ends_with?: String;
  css_not_ends_with?: String;
  AND?: BannerImageWhereInput[] | BannerImageWhereInput;
  OR?: BannerImageWhereInput[] | BannerImageWhereInput;
  NOT?: BannerImageWhereInput[] | BannerImageWhereInput;
}

export interface ProductUpdateDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export type VariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateManyWithoutProductInput {
  create?: ReviewCreateWithoutProductInput[] | ReviewCreateWithoutProductInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    | ReviewUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    | ReviewUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?: ReviewScalarWhereInput[] | ReviewScalarWhereInput;
  updateMany?:
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput;
}

export type VoteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutProductDataInput;
}

export interface ProductSpecCreateInput {
  title: String;
  badges?: ProductSpecCreatebadgesInput;
  productSpecDescs?: ProductSpecDescCreateManyWithoutProductSpecInput;
  product: ProductCreateOneWithoutSpecsInput;
}

export interface ReviewUpdateWithoutProductDataInput {
  title?: String;
  description?: String;
  author?: UserUpdateOneWithoutReviewsInput;
  votes?: VoteUpdateOneWithoutReviewInput;
}

export interface BannerImageCreateWithoutBannerInput {
  image: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface UserUpdateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  update?: UserUpdateWithoutReviewsDataInput;
  upsert?: UserUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface BannerImageUpdateWithoutBannerDataInput {
  image?: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface UserUpdateWithoutReviewsDataInput {
  email?: String;
  password?: String;
  name?: String;
}

export interface BannerImageUpdateManyDataInput {
  image?: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface BannerImageCreateInput {
  banner: BannerCreateOneWithoutImagesInput;
  image: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface ReviewUpsertWithWhereUniqueWithoutProductInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutProductDataInput;
  create: ReviewCreateWithoutProductInput;
}

export interface BannerUpdateOneRequiredWithoutImagesInput {
  create?: BannerCreateWithoutImagesInput;
  update?: BannerUpdateWithoutImagesDataInput;
  upsert?: BannerUpsertWithoutImagesInput;
  connect?: BannerWhereUniqueInput;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface CartCreateInput {
  user: UserCreateOneInput;
  product: ProductCreateOneInput;
  qty?: Int;
}

export interface CartUpdateManyMutationInput {
  qty?: Int;
}

export interface ReviewCreateWithoutAuthorInput {
  title?: String;
  description?: String;
  product: ProductCreateOneWithoutReviewsInput;
  votes?: VoteCreateOneWithoutReviewInput;
}

export interface CategoryCreateInput {
  categoryKey?: CategoryKey;
  name: String;
  subCategories?: CategoryCreatesubCategoriesInput;
  products?: ProductCreateManyWithoutCategoryInput;
}

export interface CategoryCreateWithoutProductsInput {
  categoryKey?: CategoryKey;
  name: String;
  subCategories?: CategoryCreatesubCategoriesInput;
}

export interface ProductCreateManyWithoutCategoryInput {
  create?:
    | ProductCreateWithoutCategoryInput[]
    | ProductCreateWithoutCategoryInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductImageCreatelargeInput {
  set?: String[] | String;
}

export interface ProductCreateWithoutCategoryInput {
  name: String;
  brand?: String;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductVariantCreateWithoutProductInput {
  colors?: VariantCreateManyInput;
  sizes?: VariantCreateManyInput;
  specs?: ProductVariantSpecCreateOneWithoutProductVariantInput;
}

export interface CategoryUpdateInput {
  categoryKey?: CategoryKey;
  name?: String;
  subCategories?: CategoryUpdatesubCategoriesInput;
  products?: ProductUpdateManyWithoutCategoryInput;
}

export interface ProductOverviewImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  product?: ProductWhereInput;
  AND?: ProductOverviewImageWhereInput[] | ProductOverviewImageWhereInput;
  OR?: ProductOverviewImageWhereInput[] | ProductOverviewImageWhereInput;
  NOT?: ProductOverviewImageWhereInput[] | ProductOverviewImageWhereInput;
}

export interface ProductUpdateManyWithoutCategoryInput {
  create?:
    | ProductCreateWithoutCategoryInput[]
    | ProductCreateWithoutCategoryInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface TopPickSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopPickWhereInput;
  AND?: TopPickSubscriptionWhereInput[] | TopPickSubscriptionWhereInput;
  OR?: TopPickSubscriptionWhereInput[] | TopPickSubscriptionWhereInput;
  NOT?: TopPickSubscriptionWhereInput[] | TopPickSubscriptionWhereInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoryDataInput;
}

export interface ProductOverviewTextSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductOverviewTextWhereInput;
  AND?:
    | ProductOverviewTextSubscriptionWhereInput[]
    | ProductOverviewTextSubscriptionWhereInput;
  OR?:
    | ProductOverviewTextSubscriptionWhereInput[]
    | ProductOverviewTextSubscriptionWhereInput;
  NOT?:
    | ProductOverviewTextSubscriptionWhereInput[]
    | ProductOverviewTextSubscriptionWhereInput;
}

export interface ProductUpdateWithoutCategoryDataInput {
  name?: String;
  brand?: String;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface BannerImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BannerImageWhereInput;
  AND?: BannerImageSubscriptionWhereInput[] | BannerImageSubscriptionWhereInput;
  OR?: BannerImageSubscriptionWhereInput[] | BannerImageSubscriptionWhereInput;
  NOT?: BannerImageSubscriptionWhereInput[] | BannerImageSubscriptionWhereInput;
}

export interface ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoryDataInput;
  create: ProductCreateWithoutCategoryInput;
}

export interface VoteUpdateInput {
  positive?: Int;
  negative?: Int;
  review?: ReviewUpdateOneWithoutVotesInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: String;
  brand_not?: String;
  brand_in?: String[] | String;
  brand_not_in?: String[] | String;
  brand_lt?: String;
  brand_lte?: String;
  brand_gt?: String;
  brand_gte?: String;
  brand_contains?: String;
  brand_not_contains?: String;
  brand_starts_with?: String;
  brand_not_starts_with?: String;
  brand_ends_with?: String;
  brand_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  unit?: String;
  unit_not?: String;
  unit_in?: String[] | String;
  unit_not_in?: String[] | String;
  unit_lt?: String;
  unit_lte?: String;
  unit_gt?: String;
  unit_gte?: String;
  unit_contains?: String;
  unit_not_contains?: String;
  unit_starts_with?: String;
  unit_not_starts_with?: String;
  unit_ends_with?: String;
  unit_not_ends_with?: String;
  discount?: Int;
  discount_not?: Int;
  discount_in?: Int[] | Int;
  discount_not_in?: Int[] | Int;
  discount_lt?: Int;
  discount_lte?: Int;
  discount_gt?: Int;
  discount_gte?: Int;
  searchString?: String;
  searchString_not?: String;
  searchString_in?: String[] | String;
  searchString_not_in?: String[] | String;
  searchString_lt?: String;
  searchString_lte?: String;
  searchString_gt?: String;
  searchString_gte?: String;
  searchString_contains?: String;
  searchString_not_contains?: String;
  searchString_starts_with?: String;
  searchString_not_starts_with?: String;
  searchString_ends_with?: String;
  searchString_not_ends_with?: String;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
  name?: String;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface TopPickUpdateInput {
  name?: String;
  products?: ProductUpdateManyInput;
}

export interface ProductUpdateManyDataInput {
  name?: String;
  brand?: String;
  price?: String;
  unit?: String;
  discount?: Int;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  searchString?: String;
}

export interface ProductUpdateOneRequiredWithoutStarsInput {
  create?: ProductCreateWithoutStarsInput;
  update?: ProductUpdateWithoutStarsDataInput;
  upsert?: ProductUpsertWithoutStarsInput;
  connect?: ProductWhereUniqueInput;
}

export interface CategoryUpdateManyMutationInput {
  categoryKey?: CategoryKey;
  name?: String;
  subCategories?: CategoryUpdatesubCategoriesInput;
}

export interface ReviewUpdateInput {
  title?: String;
  description?: String;
  product?: ProductUpdateOneRequiredWithoutReviewsInput;
  author?: UserUpdateOneWithoutReviewsInput;
  votes?: VoteUpdateOneWithoutReviewInput;
}

export interface PopularCategoryCreateInput {
  category?: CategoryCreateOneInput;
  image?: String;
}

export type ProductVariantSpecWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoryCreateOneInput {
  create?: CategoryCreateInput;
  connect?: CategoryWhereUniqueInput;
}

export interface ProductCreateWithoutVariantsInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface PopularCategoryUpdateInput {
  category?: CategoryUpdateOneInput;
  image?: String;
}

export interface TopPickWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: TopPickWhereInput[] | TopPickWhereInput;
  OR?: TopPickWhereInput[] | TopPickWhereInput;
  NOT?: TopPickWhereInput[] | TopPickWhereInput;
}

export interface CategoryUpdateOneInput {
  create?: CategoryCreateInput;
  update?: CategoryUpdateDataInput;
  upsert?: CategoryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CategoryWhereUniqueInput;
}

export interface ProductSpecDescCreateInput {
  title?: String;
  texts?: ProductSpecDescCreatetextsInput;
  productSpec: ProductSpecCreateOneWithoutProductSpecDescsInput;
}

export interface CategoryUpdateDataInput {
  categoryKey?: CategoryKey;
  name?: String;
  subCategories?: CategoryUpdatesubCategoriesInput;
  products?: ProductUpdateManyWithoutCategoryInput;
}

export interface ProductCreateWithoutSpecsInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  searchString?: String;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface BannerImageUpdateManyWithoutBannerInput {
  create?:
    | BannerImageCreateWithoutBannerInput[]
    | BannerImageCreateWithoutBannerInput;
  delete?: BannerImageWhereUniqueInput[] | BannerImageWhereUniqueInput;
  connect?: BannerImageWhereUniqueInput[] | BannerImageWhereUniqueInput;
  disconnect?: BannerImageWhereUniqueInput[] | BannerImageWhereUniqueInput;
  update?:
    | BannerImageUpdateWithWhereUniqueWithoutBannerInput[]
    | BannerImageUpdateWithWhereUniqueWithoutBannerInput;
  upsert?:
    | BannerImageUpsertWithWhereUniqueWithoutBannerInput[]
    | BannerImageUpsertWithWhereUniqueWithoutBannerInput;
  deleteMany?: BannerImageScalarWhereInput[] | BannerImageScalarWhereInput;
  updateMany?:
    | BannerImageUpdateManyWithWhereNestedInput[]
    | BannerImageUpdateManyWithWhereNestedInput;
}

export interface PopularCategoryUpdateManyMutationInput {
  image?: String;
}

export interface ProductOverviewTextUpdateManyMutationInput {
  text?: String;
  pairs?: ProductOverviewTextUpdatepairsInput;
}

export interface ProductUpdateInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface BannerUpsertWithoutImagesInput {
  update: BannerUpdateWithoutImagesDataInput;
  create: BannerCreateWithoutImagesInput;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  brand?: String;
  price?: String;
  unit?: String;
  discount?: Int;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  searchString?: String;
}

export interface ProductCreateWithoutReviewsInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductImageCreateInput {
  product: ProductCreateOneWithoutImagesInput;
  small?: String;
  medium?: String;
  large?: ProductImageCreatelargeInput;
}

export interface ProductCreatemiscsInput {
  set?: String[] | String;
}

export interface ProductCreateOneWithoutImagesInput {
  create?: ProductCreateWithoutImagesInput;
  connect?: ProductWhereUniqueInput;
}

export interface VoteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  positive?: Int;
  positive_not?: Int;
  positive_in?: Int[] | Int;
  positive_not_in?: Int[] | Int;
  positive_lt?: Int;
  positive_lte?: Int;
  positive_gt?: Int;
  positive_gte?: Int;
  negative?: Int;
  negative_not?: Int;
  negative_in?: Int[] | Int;
  negative_not_in?: Int[] | Int;
  negative_lt?: Int;
  negative_lte?: Int;
  negative_gt?: Int;
  negative_gte?: Int;
  review?: ReviewWhereInput;
  AND?: VoteWhereInput[] | VoteWhereInput;
  OR?: VoteWhereInput[] | VoteWhereInput;
  NOT?: VoteWhereInput[] | VoteWhereInput;
}

export interface ProductCreateWithoutImagesInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface PopularCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PopularCategoryWhereInput;
  AND?:
    | PopularCategorySubscriptionWhereInput[]
    | PopularCategorySubscriptionWhereInput;
  OR?:
    | PopularCategorySubscriptionWhereInput[]
    | PopularCategorySubscriptionWhereInput;
  NOT?:
    | PopularCategorySubscriptionWhereInput[]
    | PopularCategorySubscriptionWhereInput;
}

export interface ProductImageUpdateInput {
  product?: ProductUpdateOneRequiredWithoutImagesInput;
  small?: String;
  medium?: String;
  large?: ProductImageUpdatelargeInput;
}

export interface VoteCreateInput {
  positive?: Int;
  negative?: Int;
  review?: ReviewCreateOneWithoutVotesInput;
}

export interface ProductUpdateOneRequiredWithoutImagesInput {
  create?: ProductCreateWithoutImagesInput;
  update?: ProductUpdateWithoutImagesDataInput;
  upsert?: ProductUpsertWithoutImagesInput;
  connect?: ProductWhereUniqueInput;
}

export interface StarsUpdateManyMutationInput {
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface ProductUpdateWithoutImagesDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductVariantUpdateWithoutSpecsDataInput {
  product?: ProductUpdateOneRequiredWithoutVariantsInput;
  colors?: VariantUpdateManyInput;
  sizes?: VariantUpdateManyInput;
}

export interface ProductUpsertWithoutImagesInput {
  update: ProductUpdateWithoutImagesDataInput;
  create: ProductCreateWithoutImagesInput;
}

export interface ProductSpecDescUpdateManyMutationInput {
  title?: String;
  texts?: ProductSpecDescUpdatetextsInput;
}

export interface ProductImageUpdateManyMutationInput {
  small?: String;
  medium?: String;
  large?: ProductImageUpdatelargeInput;
}

export interface ProductUpdateWithoutSpecsDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductOverviewImageCreateInput {
  label?: String;
  image?: String;
  product: ProductCreateOneWithoutOverviewImagesInput;
}

export interface BannerImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  css?: String;
  css_not?: String;
  css_in?: String[] | String;
  css_not_in?: String[] | String;
  css_lt?: String;
  css_lte?: String;
  css_gt?: String;
  css_gte?: String;
  css_contains?: String;
  css_not_contains?: String;
  css_starts_with?: String;
  css_not_starts_with?: String;
  css_ends_with?: String;
  css_not_ends_with?: String;
  AND?: BannerImageScalarWhereInput[] | BannerImageScalarWhereInput;
  OR?: BannerImageScalarWhereInput[] | BannerImageScalarWhereInput;
  NOT?: BannerImageScalarWhereInput[] | BannerImageScalarWhereInput;
}

export interface ProductCreateOneWithoutOverviewImagesInput {
  create?: ProductCreateWithoutOverviewImagesInput;
  connect?: ProductWhereUniqueInput;
}

export interface UserCreateInput {
  email: String;
  password: String;
  name: String;
  reviews?: ReviewCreateManyWithoutAuthorInput;
}

export interface ProductCreateWithoutOverviewImagesInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  product?: ProductWhereInput;
  author?: UserWhereInput;
  votes?: VoteWhereInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface ProductOverviewImageUpdateInput {
  label?: String;
  image?: String;
  product?: ProductUpdateOneRequiredWithoutOverviewImagesInput;
}

export interface ReviewUpsertWithoutVotesInput {
  update: ReviewUpdateWithoutVotesDataInput;
  create: ReviewCreateWithoutVotesInput;
}

export interface ProductUpdateOneRequiredWithoutOverviewImagesInput {
  create?: ProductCreateWithoutOverviewImagesInput;
  update?: ProductUpdateWithoutOverviewImagesDataInput;
  upsert?: ProductUpsertWithoutOverviewImagesInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductCreateOneWithoutStarsInput {
  create?: ProductCreateWithoutStarsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductUpdateWithoutOverviewImagesDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  variants?: ProductVariantUpdateOneWithoutProductInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductSpecCreateWithoutProductSpecDescsInput {
  title: String;
  badges?: ProductSpecCreatebadgesInput;
  product: ProductCreateOneWithoutSpecsInput;
}

export interface ProductUpsertWithoutOverviewImagesInput {
  update: ProductUpdateWithoutOverviewImagesDataInput;
  create: ProductCreateWithoutOverviewImagesInput;
}

export interface BannerCreateWithoutImagesInput {
  marketing: String;
}

export interface ProductOverviewImageUpdateManyMutationInput {
  label?: String;
  image?: String;
}

export type CartWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductOverviewTextUpdateInput {
  text?: String;
  pairs?: ProductOverviewTextUpdatepairsInput;
  product?: ProductUpdateOneRequiredWithoutOverviewTextsInput;
}

export interface ProductCreateWithoutOverviewTextsInput {
  name: String;
  brand?: String;
  category?: CategoryCreateOneWithoutProductsInput;
  price: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageCreateOneWithoutProductInput;
  badges?: ProductCreatebadgesInput;
  miscs?: ProductCreatemiscsInput;
  variants?: ProductVariantCreateOneWithoutProductInput;
  stars?: StarsCreateOneWithoutProductInput;
  reviews?: ReviewCreateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageCreateManyWithoutProductInput;
  specs?: ProductSpecCreateManyWithoutProductInput;
  searchString?: String;
}

export interface ProductCreateOneWithoutOverviewTextsInput {
  create?: ProductCreateWithoutOverviewTextsInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductOverviewTextCreateInput {
  text?: String;
  pairs?: ProductOverviewTextCreatepairsInput;
  product: ProductCreateOneWithoutOverviewTextsInput;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ProductImageCreateOneWithoutProductInput {
  create?: ProductImageCreateWithoutProductInput;
  connect?: ProductImageWhereUniqueInput;
}

export interface BannerCreateInput {
  marketing: String;
  images?: BannerImageCreateManyWithoutBannerInput;
}

export interface ProductUpdateWithoutVariantsDataInput {
  name?: String;
  brand?: String;
  category?: CategoryUpdateOneWithoutProductsInput;
  price?: String;
  unit?: String;
  discount?: Int;
  images?: ProductImageUpdateOneWithoutProductInput;
  badges?: ProductUpdatebadgesInput;
  miscs?: ProductUpdatemiscsInput;
  stars?: StarsUpdateOneWithoutProductInput;
  reviews?: ReviewUpdateManyWithoutProductInput;
  overviewTexts?: ProductOverviewTextUpdateManyWithoutProductInput;
  overviewImages?: ProductOverviewImageUpdateManyWithoutProductInput;
  specs?: ProductSpecUpdateManyWithoutProductInput;
  searchString?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VotePreviousValues {
  id: ID_Output;
  positive?: Int;
  negative?: Int;
}

export interface VotePreviousValuesPromise
  extends Promise<VotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  positive: () => Promise<Int>;
  negative: () => Promise<Int>;
}

export interface VotePreviousValuesSubscription
  extends Promise<AsyncIterator<VotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  positive: () => Promise<AsyncIterator<Int>>;
  negative: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface Review {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title?: String;
  description?: String;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  author: <T = UserPromise>() => T;
  votes: <T = VotePromise>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
  author: <T = UserSubscription>() => T;
  votes: <T = VoteSubscription>() => T;
}

export interface BannerEdge {
  node: Banner;
  cursor: String;
}

export interface BannerEdgePromise extends Promise<BannerEdge>, Fragmentable {
  node: <T = BannerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BannerEdgeSubscription
  extends Promise<AsyncIterator<BannerEdge>>,
    Fragmentable {
  node: <T = BannerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCart {
  count: Int;
}

export interface AggregateCartPromise
  extends Promise<AggregateCart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCartSubscription
  extends Promise<AsyncIterator<AggregateCart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VariantSubscriptionPayload {
  mutation: MutationType;
  node: Variant;
  updatedFields: String[];
  previousValues: VariantPreviousValues;
}

export interface VariantSubscriptionPayloadPromise
  extends Promise<VariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariantPreviousValuesPromise>() => T;
}

export interface VariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariantPreviousValuesSubscription>() => T;
}

export interface AggregateVote {
  count: Int;
}

export interface AggregateVotePromise
  extends Promise<AggregateVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoteSubscription
  extends Promise<AsyncIterator<AggregateVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CartEdge {
  node: Cart;
  cursor: String;
}

export interface CartEdgePromise extends Promise<CartEdge>, Fragmentable {
  node: <T = CartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CartEdgeSubscription
  extends Promise<AsyncIterator<CartEdge>>,
    Fragmentable {
  node: <T = CartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VoteConnection {
  pageInfo: PageInfo;
  edges: VoteEdge[];
}

export interface VoteConnectionPromise
  extends Promise<VoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoteEdge>>() => T;
  aggregate: <T = AggregateVotePromise>() => T;
}

export interface VoteConnectionSubscription
  extends Promise<AsyncIterator<VoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoteSubscription>() => T;
}

export interface CartConnection {
  pageInfo: PageInfo;
  edges: CartEdge[];
}

export interface CartConnectionPromise
  extends Promise<CartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CartEdge>>() => T;
  aggregate: <T = AggregateCartPromise>() => T;
}

export interface CartConnectionSubscription
  extends Promise<AsyncIterator<CartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCartSubscription>() => T;
}

export interface AggregateVariant {
  count: Int;
}

export interface AggregateVariantPromise
  extends Promise<AggregateVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariantSubscription
  extends Promise<AsyncIterator<AggregateVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBanner {
  count: Int;
}

export interface AggregateBannerPromise
  extends Promise<AggregateBanner>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBannerSubscription
  extends Promise<AsyncIterator<AggregateBanner>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VariantConnection {
  pageInfo: PageInfo;
  edges: VariantEdge[];
}

export interface VariantConnectionPromise
  extends Promise<VariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariantEdge>>() => T;
  aggregate: <T = AggregateVariantPromise>() => T;
}

export interface VariantConnectionSubscription
  extends Promise<AsyncIterator<VariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariantSubscription>() => T;
}

export interface Banner {
  id: ID_Output;
  marketing: String;
}

export interface BannerPromise extends Promise<Banner>, Fragmentable {
  id: () => Promise<ID_Output>;
  marketing: () => Promise<String>;
  images: <T = FragmentableArray<BannerImage>>(
    args?: {
      where?: BannerImageWhereInput;
      orderBy?: BannerImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BannerSubscription
  extends Promise<AsyncIterator<Banner>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  marketing: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<BannerImageSubscription>>>(
    args?: {
      where?: BannerImageWhereInput;
      orderBy?: BannerImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BannerSubscriptionPayload {
  mutation: MutationType;
  node: Banner;
  updatedFields: String[];
  previousValues: BannerPreviousValues;
}

export interface BannerSubscriptionPayloadPromise
  extends Promise<BannerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BannerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BannerPreviousValuesPromise>() => T;
}

export interface BannerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BannerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BannerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BannerPreviousValuesSubscription>() => T;
}

export interface AggregateTopPick {
  count: Int;
}

export interface AggregateTopPickPromise
  extends Promise<AggregateTopPick>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopPickSubscription
  extends Promise<AsyncIterator<AggregateTopPick>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BannerPreviousValues {
  id: ID_Output;
  marketing: String;
}

export interface BannerPreviousValuesPromise
  extends Promise<BannerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  marketing: () => Promise<String>;
}

export interface BannerPreviousValuesSubscription
  extends Promise<AsyncIterator<BannerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  marketing: () => Promise<AsyncIterator<String>>;
}

export interface TopPickConnection {
  pageInfo: PageInfo;
  edges: TopPickEdge[];
}

export interface TopPickConnectionPromise
  extends Promise<TopPickConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopPickEdge>>() => T;
  aggregate: <T = AggregateTopPickPromise>() => T;
}

export interface TopPickConnectionSubscription
  extends Promise<AsyncIterator<TopPickConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopPickEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopPickSubscription>() => T;
}

export interface Vote {
  id: ID_Output;
  positive?: Int;
  negative?: Int;
}

export interface VotePromise extends Promise<Vote>, Fragmentable {
  id: () => Promise<ID_Output>;
  positive: () => Promise<Int>;
  negative: () => Promise<Int>;
  review: <T = ReviewPromise>() => T;
}

export interface VoteSubscription
  extends Promise<AsyncIterator<Vote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  positive: () => Promise<AsyncIterator<Int>>;
  negative: () => Promise<AsyncIterator<Int>>;
  review: <T = ReviewSubscription>() => T;
}

export interface AggregateStars {
  count: Int;
}

export interface AggregateStarsPromise
  extends Promise<AggregateStars>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStarsSubscription
  extends Promise<AsyncIterator<AggregateStars>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BannerImageSubscriptionPayload {
  mutation: MutationType;
  node: BannerImage;
  updatedFields: String[];
  previousValues: BannerImagePreviousValues;
}

export interface BannerImageSubscriptionPayloadPromise
  extends Promise<BannerImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BannerImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BannerImagePreviousValuesPromise>() => T;
}

export interface BannerImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BannerImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BannerImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BannerImagePreviousValuesSubscription>() => T;
}

export interface StarsConnection {
  pageInfo: PageInfo;
  edges: StarsEdge[];
}

export interface StarsConnectionPromise
  extends Promise<StarsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StarsEdge>>() => T;
  aggregate: <T = AggregateStarsPromise>() => T;
}

export interface StarsConnectionSubscription
  extends Promise<AsyncIterator<StarsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StarsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStarsSubscription>() => T;
}

export interface BannerImagePreviousValues {
  id: ID_Output;
  image: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface BannerImagePreviousValuesPromise
  extends Promise<BannerImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  alt: () => Promise<String>;
  url: () => Promise<String>;
  css: () => Promise<String>;
}

export interface BannerImagePreviousValuesSubscription
  extends Promise<AsyncIterator<BannerImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  css: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSpecDesc {
  id: ID_Output;
  title?: String;
  texts: String[];
}

export interface ProductSpecDescPromise
  extends Promise<ProductSpecDesc>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  texts: () => Promise<String[]>;
  productSpec: <T = ProductSpecPromise>() => T;
}

export interface ProductSpecDescSubscription
  extends Promise<AsyncIterator<ProductSpecDesc>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  texts: () => Promise<AsyncIterator<String[]>>;
  productSpec: <T = ProductSpecSubscription>() => T;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface CartSubscriptionPayload {
  mutation: MutationType;
  node: Cart;
  updatedFields: String[];
  previousValues: CartPreviousValues;
}

export interface CartSubscriptionPayloadPromise
  extends Promise<CartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CartPreviousValuesPromise>() => T;
}

export interface CartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CartPreviousValuesSubscription>() => T;
}

export interface ProductVariantSpecEdge {
  node: ProductVariantSpec;
  cursor: String;
}

export interface ProductVariantSpecEdgePromise
  extends Promise<ProductVariantSpecEdge>,
    Fragmentable {
  node: <T = ProductVariantSpecPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantSpecEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantSpecEdge>>,
    Fragmentable {
  node: <T = ProductVariantSpecSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CartPreviousValues {
  id: ID_Output;
  qty?: Int;
}

export interface CartPreviousValuesPromise
  extends Promise<CartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  qty: () => Promise<Int>;
}

export interface CartPreviousValuesSubscription
  extends Promise<AsyncIterator<CartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  qty: () => Promise<AsyncIterator<Int>>;
}

export interface BannerImage {
  id: ID_Output;
  image: String;
  alt?: String;
  url?: String;
  css?: String;
}

export interface BannerImagePromise extends Promise<BannerImage>, Fragmentable {
  id: () => Promise<ID_Output>;
  banner: <T = BannerPromise>() => T;
  image: () => Promise<String>;
  alt: () => Promise<String>;
  url: () => Promise<String>;
  css: () => Promise<String>;
}

export interface BannerImageSubscription
  extends Promise<AsyncIterator<BannerImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  banner: <T = BannerSubscription>() => T;
  image: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  css: () => Promise<AsyncIterator<String>>;
}

export interface ProductSpec {
  id: ID_Output;
  title: String;
  badges: String[];
}

export interface ProductSpecPromise extends Promise<ProductSpec>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  badges: () => Promise<String[]>;
  productSpecDescs: <T = FragmentableArray<ProductSpecDesc>>(
    args?: {
      where?: ProductSpecDescWhereInput;
      orderBy?: ProductSpecDescOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  product: <T = ProductPromise>() => T;
}

export interface ProductSpecSubscription
  extends Promise<AsyncIterator<ProductSpec>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  badges: () => Promise<AsyncIterator<String[]>>;
  productSpecDescs: <T = Promise<AsyncIterator<ProductSpecDescSubscription>>>(
    args?: {
      where?: ProductSpecDescWhereInput;
      orderBy?: ProductSpecDescOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  product: <T = ProductSubscription>() => T;
}

export interface ProductVariantEdge {
  node: ProductVariant;
  cursor: String;
}

export interface ProductVariantEdgePromise
  extends Promise<ProductVariantEdge>,
    Fragmentable {
  node: <T = ProductVariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantEdge>>,
    Fragmentable {
  node: <T = ProductVariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface BannerConnection {
  pageInfo: PageInfo;
  edges: BannerEdge[];
}

export interface BannerConnectionPromise
  extends Promise<BannerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BannerEdge>>() => T;
  aggregate: <T = AggregateBannerPromise>() => T;
}

export interface BannerConnectionSubscription
  extends Promise<AsyncIterator<BannerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BannerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBannerSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  categoryKey?: CategoryKey;
  name: String;
  subCategories: String[];
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  categoryKey: () => Promise<CategoryKey>;
  name: () => Promise<String>;
  subCategories: () => Promise<String[]>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  categoryKey: () => Promise<AsyncIterator<CategoryKey>>;
  name: () => Promise<AsyncIterator<String>>;
  subCategories: () => Promise<AsyncIterator<String[]>>;
}

export interface ProductSpecDescEdge {
  node: ProductSpecDesc;
  cursor: String;
}

export interface ProductSpecDescEdgePromise
  extends Promise<ProductSpecDescEdge>,
    Fragmentable {
  node: <T = ProductSpecDescPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductSpecDescEdgeSubscription
  extends Promise<AsyncIterator<ProductSpecDescEdge>>,
    Fragmentable {
  node: <T = ProductSpecDescSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BannerImageConnection {
  pageInfo: PageInfo;
  edges: BannerImageEdge[];
}

export interface BannerImageConnectionPromise
  extends Promise<BannerImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BannerImageEdge>>() => T;
  aggregate: <T = AggregateBannerImagePromise>() => T;
}

export interface BannerImageConnectionSubscription
  extends Promise<AsyncIterator<BannerImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BannerImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBannerImageSubscription>() => T;
}

export interface AggregateProductSpec {
  count: Int;
}

export interface AggregateProductSpecPromise
  extends Promise<AggregateProductSpec>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSpecSubscription
  extends Promise<AsyncIterator<AggregateProductSpec>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PopularCategorySubscriptionPayload {
  mutation: MutationType;
  node: PopularCategory;
  updatedFields: String[];
  previousValues: PopularCategoryPreviousValues;
}

export interface PopularCategorySubscriptionPayloadPromise
  extends Promise<PopularCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PopularCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PopularCategoryPreviousValuesPromise>() => T;
}

export interface PopularCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PopularCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PopularCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PopularCategoryPreviousValuesSubscription>() => T;
}

export interface ProductSpecConnection {
  pageInfo: PageInfo;
  edges: ProductSpecEdge[];
}

export interface ProductSpecConnectionPromise
  extends Promise<ProductSpecConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductSpecEdge>>() => T;
  aggregate: <T = AggregateProductSpecPromise>() => T;
}

export interface ProductSpecConnectionSubscription
  extends Promise<AsyncIterator<ProductSpecConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductSpecEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSpecSubscription>() => T;
}

export interface PopularCategoryPreviousValues {
  id: ID_Output;
  image?: String;
}

export interface PopularCategoryPreviousValuesPromise
  extends Promise<PopularCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
}

export interface PopularCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<PopularCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface ProductOverviewTextEdge {
  node: ProductOverviewText;
  cursor: String;
}

export interface ProductOverviewTextEdgePromise
  extends Promise<ProductOverviewTextEdge>,
    Fragmentable {
  node: <T = ProductOverviewTextPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductOverviewTextEdgeSubscription
  extends Promise<AsyncIterator<ProductOverviewTextEdge>>,
    Fragmentable {
  node: <T = ProductOverviewTextSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductOverviewImage {
  id: ID_Output;
  label?: String;
  image?: String;
}

export interface ProductOverviewImagePromise
  extends Promise<ProductOverviewImage>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  image: () => Promise<String>;
  product: <T = ProductPromise>() => T;
}

export interface ProductOverviewImageSubscription
  extends Promise<AsyncIterator<ProductOverviewImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
}

export interface AggregateProductOverviewImage {
  count: Int;
}

export interface AggregateProductOverviewImagePromise
  extends Promise<AggregateProductOverviewImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductOverviewImageSubscription
  extends Promise<AsyncIterator<AggregateProductOverviewImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductOverviewImageConnection {
  pageInfo: PageInfo;
  edges: ProductOverviewImageEdge[];
}

export interface ProductOverviewImageConnectionPromise
  extends Promise<ProductOverviewImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductOverviewImageEdge>>() => T;
  aggregate: <T = AggregateProductOverviewImagePromise>() => T;
}

export interface ProductOverviewImageConnectionSubscription
  extends Promise<AsyncIterator<ProductOverviewImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductOverviewImageEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductOverviewImageSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  brand?: String;
  price: String;
  unit?: String;
  discount?: Int;
  badges: String[];
  miscs: String[];
  searchString?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  brand: () => Promise<String>;
  price: () => Promise<String>;
  unit: () => Promise<String>;
  discount: () => Promise<Int>;
  badges: () => Promise<String[]>;
  miscs: () => Promise<String[]>;
  searchString: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<Int>>;
  badges: () => Promise<AsyncIterator<String[]>>;
  miscs: () => Promise<AsyncIterator<String[]>>;
  searchString: () => Promise<AsyncIterator<String>>;
}

export interface ProductImageEdge {
  node: ProductImage;
  cursor: String;
}

export interface ProductImageEdgePromise
  extends Promise<ProductImageEdge>,
    Fragmentable {
  node: <T = ProductImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductImageEdgeSubscription
  extends Promise<AsyncIterator<ProductImageEdge>>,
    Fragmentable {
  node: <T = ProductImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BannerImageEdge {
  node: BannerImage;
  cursor: String;
}

export interface BannerImageEdgePromise
  extends Promise<BannerImageEdge>,
    Fragmentable {
  node: <T = BannerImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BannerImageEdgeSubscription
  extends Promise<AsyncIterator<BannerImageEdge>>,
    Fragmentable {
  node: <T = BannerImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductImageSubscriptionPayload {
  mutation: MutationType;
  node: ProductImage;
  updatedFields: String[];
  previousValues: ProductImagePreviousValues;
}

export interface ProductImageSubscriptionPayloadPromise
  extends Promise<ProductImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductImagePreviousValuesPromise>() => T;
}

export interface ProductImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductImagePreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductImagePreviousValues {
  id: ID_Output;
  small?: String;
  medium?: String;
  large: String[];
}

export interface ProductImagePreviousValuesPromise
  extends Promise<ProductImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  small: () => Promise<String>;
  medium: () => Promise<String>;
  large: () => Promise<String[]>;
}

export interface ProductImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  small: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  large: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregatePopularCategory {
  count: Int;
}

export interface AggregatePopularCategoryPromise
  extends Promise<AggregatePopularCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePopularCategorySubscription
  extends Promise<AsyncIterator<AggregatePopularCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductOverviewText {
  id: ID_Output;
  text?: String;
  pairs: String[];
}

export interface ProductOverviewTextPromise
  extends Promise<ProductOverviewText>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  pairs: () => Promise<String[]>;
  product: <T = ProductPromise>() => T;
}

export interface ProductOverviewTextSubscription
  extends Promise<AsyncIterator<ProductOverviewText>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  pairs: () => Promise<AsyncIterator<String[]>>;
  product: <T = ProductSubscription>() => T;
}

export interface PopularCategoryConnection {
  pageInfo: PageInfo;
  edges: PopularCategoryEdge[];
}

export interface PopularCategoryConnectionPromise
  extends Promise<PopularCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PopularCategoryEdge>>() => T;
  aggregate: <T = AggregatePopularCategoryPromise>() => T;
}

export interface PopularCategoryConnectionSubscription
  extends Promise<AsyncIterator<PopularCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PopularCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePopularCategorySubscription>() => T;
}

export interface ProductOverviewImageSubscriptionPayload {
  mutation: MutationType;
  node: ProductOverviewImage;
  updatedFields: String[];
  previousValues: ProductOverviewImagePreviousValues;
}

export interface ProductOverviewImageSubscriptionPayloadPromise
  extends Promise<ProductOverviewImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductOverviewImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductOverviewImagePreviousValuesPromise>() => T;
}

export interface ProductOverviewImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductOverviewImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductOverviewImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductOverviewImagePreviousValuesSubscription>() => T;
}

export interface PopularCategory {
  id: ID_Output;
  image?: String;
}

export interface PopularCategoryPromise
  extends Promise<PopularCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = CategoryPromise>() => T;
  image: () => Promise<String>;
}

export interface PopularCategorySubscription
  extends Promise<AsyncIterator<PopularCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = CategorySubscription>() => T;
  image: () => Promise<AsyncIterator<String>>;
}

export interface ProductOverviewImagePreviousValues {
  id: ID_Output;
  label?: String;
  image?: String;
}

export interface ProductOverviewImagePreviousValuesPromise
  extends Promise<ProductOverviewImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  image: () => Promise<String>;
}

export interface ProductOverviewImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductOverviewImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBannerImage {
  count: Int;
}

export interface AggregateBannerImagePromise
  extends Promise<AggregateBannerImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBannerImageSubscription
  extends Promise<AsyncIterator<AggregateBannerImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VoteEdge {
  node: Vote;
  cursor: String;
}

export interface VoteEdgePromise extends Promise<VoteEdge>, Fragmentable {
  node: <T = VotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoteEdgeSubscription
  extends Promise<AsyncIterator<VoteEdge>>,
    Fragmentable {
  node: <T = VoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductOverviewTextSubscriptionPayload {
  mutation: MutationType;
  node: ProductOverviewText;
  updatedFields: String[];
  previousValues: ProductOverviewTextPreviousValues;
}

export interface ProductOverviewTextSubscriptionPayloadPromise
  extends Promise<ProductOverviewTextSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductOverviewTextPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductOverviewTextPreviousValuesPromise>() => T;
}

export interface ProductOverviewTextSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductOverviewTextSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductOverviewTextSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductOverviewTextPreviousValuesSubscription>() => T;
}

export interface VariantEdge {
  node: Variant;
  cursor: String;
}

export interface VariantEdgePromise extends Promise<VariantEdge>, Fragmentable {
  node: <T = VariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariantEdgeSubscription
  extends Promise<AsyncIterator<VariantEdge>>,
    Fragmentable {
  node: <T = VariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductOverviewTextPreviousValues {
  id: ID_Output;
  text?: String;
  pairs: String[];
}

export interface ProductOverviewTextPreviousValuesPromise
  extends Promise<ProductOverviewTextPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  pairs: () => Promise<String[]>;
}

export interface ProductOverviewTextPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductOverviewTextPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  pairs: () => Promise<AsyncIterator<String[]>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Stars {
  id: ID_Output;
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface StarsPromise extends Promise<Stars>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  one: () => Promise<Int>;
  two: () => Promise<Int>;
  three: () => Promise<Int>;
  four: () => Promise<Int>;
  five: () => Promise<Int>;
}

export interface StarsSubscription
  extends Promise<AsyncIterator<Stars>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  one: () => Promise<AsyncIterator<Int>>;
  two: () => Promise<AsyncIterator<Int>>;
  three: () => Promise<AsyncIterator<Int>>;
  four: () => Promise<AsyncIterator<Int>>;
  five: () => Promise<AsyncIterator<Int>>;
}

export interface TopPick {
  id: ID_Output;
  name: String;
}

export interface TopPickPromise extends Promise<TopPick>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopPickSubscription
  extends Promise<AsyncIterator<TopPick>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSpecSubscriptionPayload {
  mutation: MutationType;
  node: ProductSpec;
  updatedFields: String[];
  previousValues: ProductSpecPreviousValues;
}

export interface ProductSpecSubscriptionPayloadPromise
  extends Promise<ProductSpecSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductSpecPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductSpecPreviousValuesPromise>() => T;
}

export interface ProductSpecSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSpecSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSpecSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductSpecPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSpecPreviousValues {
  id: ID_Output;
  title: String;
  badges: String[];
}

export interface ProductSpecPreviousValuesPromise
  extends Promise<ProductSpecPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  badges: () => Promise<String[]>;
}

export interface ProductSpecPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductSpecPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  badges: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateProductVariantSpec {
  count: Int;
}

export interface AggregateProductVariantSpecPromise
  extends Promise<AggregateProductVariantSpec>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantSpecSubscription
  extends Promise<AsyncIterator<AggregateProductVariantSpec>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantSpec {
  id: ID_Output;
}

export interface ProductVariantSpecPromise
  extends Promise<ProductVariantSpec>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productVariant: <T = ProductVariantPromise>() => T;
  color: <T = VariantPromise>() => T;
  size: <T = VariantPromise>() => T;
}

export interface ProductVariantSpecSubscription
  extends Promise<AsyncIterator<ProductVariantSpec>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productVariant: <T = ProductVariantSubscription>() => T;
  color: <T = VariantSubscription>() => T;
  size: <T = VariantSubscription>() => T;
}

export interface AggregateProductVariant {
  count: Int;
}

export interface AggregateProductVariantPromise
  extends Promise<AggregateProductVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantSubscription
  extends Promise<AsyncIterator<AggregateProductVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSpecDescSubscriptionPayload {
  mutation: MutationType;
  node: ProductSpecDesc;
  updatedFields: String[];
  previousValues: ProductSpecDescPreviousValues;
}

export interface ProductSpecDescSubscriptionPayloadPromise
  extends Promise<ProductSpecDescSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductSpecDescPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductSpecDescPreviousValuesPromise>() => T;
}

export interface ProductSpecDescSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSpecDescSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSpecDescSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductSpecDescPreviousValuesSubscription>() => T;
}

export interface AggregateProductSpecDesc {
  count: Int;
}

export interface AggregateProductSpecDescPromise
  extends Promise<AggregateProductSpecDesc>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSpecDescSubscription
  extends Promise<AsyncIterator<AggregateProductSpecDesc>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSpecDescPreviousValues {
  id: ID_Output;
  title?: String;
  texts: String[];
}

export interface ProductSpecDescPreviousValuesPromise
  extends Promise<ProductSpecDescPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  texts: () => Promise<String[]>;
}

export interface ProductSpecDescPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductSpecDescPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  texts: () => Promise<AsyncIterator<String[]>>;
}

export interface ProductSpecEdge {
  node: ProductSpec;
  cursor: String;
}

export interface ProductSpecEdgePromise
  extends Promise<ProductSpecEdge>,
    Fragmentable {
  node: <T = ProductSpecPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductSpecEdgeSubscription
  extends Promise<AsyncIterator<ProductSpecEdge>>,
    Fragmentable {
  node: <T = ProductSpecSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Variant {
  id: ID_Output;
  name: String;
  value: String;
  type?: VariantType;
}

export interface VariantPromise extends Promise<Variant>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  type: () => Promise<VariantType>;
}

export interface VariantSubscription
  extends Promise<AsyncIterator<Variant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<VariantType>>;
}

export interface ProductOverviewTextConnection {
  pageInfo: PageInfo;
  edges: ProductOverviewTextEdge[];
}

export interface ProductOverviewTextConnectionPromise
  extends Promise<ProductOverviewTextConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductOverviewTextEdge>>() => T;
  aggregate: <T = AggregateProductOverviewTextPromise>() => T;
}

export interface ProductOverviewTextConnectionSubscription
  extends Promise<AsyncIterator<ProductOverviewTextConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductOverviewTextEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductOverviewTextSubscription>() => T;
}

export interface ProductVariantSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariant;
  updatedFields: String[];
  previousValues: ProductVariantPreviousValues;
}

export interface ProductVariantSubscriptionPayloadPromise
  extends Promise<ProductVariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantPreviousValuesPromise>() => T;
}

export interface ProductVariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantPreviousValuesSubscription>() => T;
}

export interface AggregateProductImage {
  count: Int;
}

export interface AggregateProductImagePromise
  extends Promise<AggregateProductImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductImageSubscription
  extends Promise<AsyncIterator<AggregateProductImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantPreviousValues {
  id: ID_Output;
}

export interface ProductVariantPreviousValuesPromise
  extends Promise<ProductVariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProductVariantPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariant {
  id: ID_Output;
}

export interface ProductVariantPromise
  extends Promise<ProductVariant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  colors: <T = FragmentableArray<Variant>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sizes: <T = FragmentableArray<Variant>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  specs: <T = ProductVariantSpecPromise>() => T;
}

export interface ProductVariantSubscription
  extends Promise<AsyncIterator<ProductVariant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  colors: <T = Promise<AsyncIterator<VariantSubscription>>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sizes: <T = Promise<AsyncIterator<VariantSubscription>>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  specs: <T = ProductVariantSpecSubscription>() => T;
}

export interface PopularCategoryEdge {
  node: PopularCategory;
  cursor: String;
}

export interface PopularCategoryEdgePromise
  extends Promise<PopularCategoryEdge>,
    Fragmentable {
  node: <T = PopularCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PopularCategoryEdgeSubscription
  extends Promise<AsyncIterator<PopularCategoryEdge>>,
    Fragmentable {
  node: <T = PopularCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductVariantSpecSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariantSpec;
  updatedFields: String[];
  previousValues: ProductVariantSpecPreviousValues;
}

export interface ProductVariantSpecSubscriptionPayloadPromise
  extends Promise<ProductVariantSpecSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantSpecPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantSpecPreviousValuesPromise>() => T;
}

export interface ProductVariantSpecSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantSpecSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantSpecSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantSpecPreviousValuesSubscription>() => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductVariantSpecPreviousValues {
  id: ID_Output;
}

export interface ProductVariantSpecPreviousValuesPromise
  extends Promise<ProductVariantSpecPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProductVariantSpecPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantSpecPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VoteSubscriptionPayload {
  mutation: MutationType;
  node: Vote;
  updatedFields: String[];
  previousValues: VotePreviousValues;
}

export interface VoteSubscriptionPayloadPromise
  extends Promise<VoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotePreviousValuesPromise>() => T;
}

export interface VoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotePreviousValuesSubscription>() => T;
}

export interface ProductImage {
  id: ID_Output;
  small?: String;
  medium?: String;
  large: String[];
}

export interface ProductImagePromise
  extends Promise<ProductImage>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  small: () => Promise<String>;
  medium: () => Promise<String>;
  large: () => Promise<String[]>;
}

export interface ProductImageSubscription
  extends Promise<AsyncIterator<ProductImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  small: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  large: () => Promise<AsyncIterator<String[]>>;
}

export interface TopPickEdge {
  node: TopPick;
  cursor: String;
}

export interface TopPickEdgePromise extends Promise<TopPickEdge>, Fragmentable {
  node: <T = TopPickPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopPickEdgeSubscription
  extends Promise<AsyncIterator<TopPickEdge>>,
    Fragmentable {
  node: <T = TopPickSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title?: String;
  description?: String;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductVariantConnection {
  pageInfo: PageInfo;
  edges: ProductVariantEdge[];
}

export interface ProductVariantConnectionPromise
  extends Promise<ProductVariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantEdge>>() => T;
  aggregate: <T = AggregateProductVariantPromise>() => T;
}

export interface ProductVariantConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductVariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductVariantSubscription>() => T;
}

export interface Cart {
  id: ID_Output;
  qty?: Int;
}

export interface CartPromise extends Promise<Cart>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  product: <T = ProductPromise>() => T;
  qty: () => Promise<Int>;
}

export interface CartSubscription
  extends Promise<AsyncIterator<Cart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  qty: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProductOverviewText {
  count: Int;
}

export interface AggregateProductOverviewTextPromise
  extends Promise<AggregateProductOverviewText>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductOverviewTextSubscription
  extends Promise<AsyncIterator<AggregateProductOverviewText>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StarsSubscriptionPayload {
  mutation: MutationType;
  node: Stars;
  updatedFields: String[];
  previousValues: StarsPreviousValues;
}

export interface StarsSubscriptionPayloadPromise
  extends Promise<StarsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StarsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StarsPreviousValuesPromise>() => T;
}

export interface StarsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StarsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StarsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StarsPreviousValuesSubscription>() => T;
}

export interface ProductImageConnection {
  pageInfo: PageInfo;
  edges: ProductImageEdge[];
}

export interface ProductImageConnectionPromise
  extends Promise<ProductImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductImageEdge>>() => T;
  aggregate: <T = AggregateProductImagePromise>() => T;
}

export interface ProductImageConnectionSubscription
  extends Promise<AsyncIterator<ProductImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductImageSubscription>() => T;
}

export interface StarsPreviousValues {
  id: ID_Output;
  one?: Int;
  two?: Int;
  three?: Int;
  four?: Int;
  five?: Int;
}

export interface StarsPreviousValuesPromise
  extends Promise<StarsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  one: () => Promise<Int>;
  two: () => Promise<Int>;
  three: () => Promise<Int>;
  four: () => Promise<Int>;
  five: () => Promise<Int>;
}

export interface StarsPreviousValuesSubscription
  extends Promise<AsyncIterator<StarsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  one: () => Promise<AsyncIterator<Int>>;
  two: () => Promise<AsyncIterator<Int>>;
  three: () => Promise<AsyncIterator<Int>>;
  four: () => Promise<AsyncIterator<Int>>;
  five: () => Promise<AsyncIterator<Int>>;
}

export interface VariantPreviousValues {
  id: ID_Output;
  name: String;
  value: String;
  type?: VariantType;
}

export interface VariantPreviousValuesPromise
  extends Promise<VariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  type: () => Promise<VariantType>;
}

export interface VariantPreviousValuesSubscription
  extends Promise<AsyncIterator<VariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<VariantType>>;
}

export interface Category {
  id: ID_Output;
  categoryKey?: CategoryKey;
  name: String;
  subCategories: String[];
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  categoryKey: () => Promise<CategoryKey>;
  name: () => Promise<String>;
  subCategories: () => Promise<String[]>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  categoryKey: () => Promise<AsyncIterator<CategoryKey>>;
  name: () => Promise<AsyncIterator<String>>;
  subCategories: () => Promise<AsyncIterator<String[]>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopPickSubscriptionPayload {
  mutation: MutationType;
  node: TopPick;
  updatedFields: String[];
  previousValues: TopPickPreviousValues;
}

export interface TopPickSubscriptionPayloadPromise
  extends Promise<TopPickSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopPickPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopPickPreviousValuesPromise>() => T;
}

export interface TopPickSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopPickSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopPickSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopPickPreviousValuesSubscription>() => T;
}

export interface ProductVariantSpecConnection {
  pageInfo: PageInfo;
  edges: ProductVariantSpecEdge[];
}

export interface ProductVariantSpecConnectionPromise
  extends Promise<ProductVariantSpecConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantSpecEdge>>() => T;
  aggregate: <T = AggregateProductVariantSpecPromise>() => T;
}

export interface ProductVariantSpecConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantSpecConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductVariantSpecEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductVariantSpecSubscription>() => T;
}

export interface ProductOverviewImageEdge {
  node: ProductOverviewImage;
  cursor: String;
}

export interface ProductOverviewImageEdgePromise
  extends Promise<ProductOverviewImageEdge>,
    Fragmentable {
  node: <T = ProductOverviewImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductOverviewImageEdgeSubscription
  extends Promise<AsyncIterator<ProductOverviewImageEdge>>,
    Fragmentable {
  node: <T = ProductOverviewImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Product {
  id: ID_Output;
  name: String;
  brand?: String;
  price: String;
  unit?: String;
  discount?: Int;
  badges: String[];
  miscs: String[];
  searchString?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  brand: () => Promise<String>;
  category: <T = CategoryPromise>() => T;
  price: () => Promise<String>;
  unit: () => Promise<String>;
  discount: () => Promise<Int>;
  images: <T = ProductImagePromise>() => T;
  badges: () => Promise<String[]>;
  miscs: () => Promise<String[]>;
  variants: <T = ProductVariantPromise>() => T;
  stars: <T = StarsPromise>() => T;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  overviewTexts: <T = FragmentableArray<ProductOverviewText>>(
    args?: {
      where?: ProductOverviewTextWhereInput;
      orderBy?: ProductOverviewTextOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  overviewImages: <T = FragmentableArray<ProductOverviewImage>>(
    args?: {
      where?: ProductOverviewImageWhereInput;
      orderBy?: ProductOverviewImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  specs: <T = FragmentableArray<ProductSpec>>(
    args?: {
      where?: ProductSpecWhereInput;
      orderBy?: ProductSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  searchString: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  category: <T = CategorySubscription>() => T;
  price: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  discount: () => Promise<AsyncIterator<Int>>;
  images: <T = ProductImageSubscription>() => T;
  badges: () => Promise<AsyncIterator<String[]>>;
  miscs: () => Promise<AsyncIterator<String[]>>;
  variants: <T = ProductVariantSubscription>() => T;
  stars: <T = StarsSubscription>() => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  overviewTexts: <T = Promise<AsyncIterator<ProductOverviewTextSubscription>>>(
    args?: {
      where?: ProductOverviewTextWhereInput;
      orderBy?: ProductOverviewTextOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  overviewImages: <
    T = Promise<AsyncIterator<ProductOverviewImageSubscription>>
  >(
    args?: {
      where?: ProductOverviewImageWhereInput;
      orderBy?: ProductOverviewImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  specs: <T = Promise<AsyncIterator<ProductSpecSubscription>>>(
    args?: {
      where?: ProductSpecWhereInput;
      orderBy?: ProductSpecOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  searchString: () => Promise<AsyncIterator<String>>;
}

export interface TopPickPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TopPickPreviousValuesPromise
  extends Promise<TopPickPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TopPickPreviousValuesSubscription
  extends Promise<AsyncIterator<TopPickPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductSpecDescConnection {
  pageInfo: PageInfo;
  edges: ProductSpecDescEdge[];
}

export interface ProductSpecDescConnectionPromise
  extends Promise<ProductSpecDescConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductSpecDescEdge>>() => T;
  aggregate: <T = AggregateProductSpecDescPromise>() => T;
}

export interface ProductSpecDescConnectionSubscription
  extends Promise<AsyncIterator<ProductSpecDescConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductSpecDescEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSpecDescSubscription>() => T;
}

export interface StarsEdge {
  node: Stars;
  cursor: String;
}

export interface StarsEdgePromise extends Promise<StarsEdge>, Fragmentable {
  node: <T = StarsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StarsEdgeSubscription
  extends Promise<AsyncIterator<StarsEdge>>,
    Fragmentable {
  node: <T = StarsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Banner",
    embedded: false
  },
  {
    name: "BannerImage",
    embedded: false
  },
  {
    name: "Cart",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "CategoryKey",
    embedded: false
  },
  {
    name: "PopularCategory",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductImage",
    embedded: false
  },
  {
    name: "ProductOverviewImage",
    embedded: false
  },
  {
    name: "ProductOverviewText",
    embedded: false
  },
  {
    name: "ProductSpec",
    embedded: false
  },
  {
    name: "ProductSpecDesc",
    embedded: false
  },
  {
    name: "ProductVariant",
    embedded: false
  },
  {
    name: "ProductVariantSpec",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "Stars",
    embedded: false
  },
  {
    name: "TopPick",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Variant",
    embedded: false
  },
  {
    name: "VariantType",
    embedded: false
  },
  {
    name: "Vote",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
